diff --git a/scripts_fortran/energyTr_computation/cmd_operators_extract_class.f b/scripts_fortran/energyTr_computation/cmd_operators_extract_class.f
deleted file mode 100644
index d44cde4..0000000
--- a/scripts_fortran/energyTr_computation/cmd_operators_extract_class.f
+++ /dev/null
@@ -1,300 +0,0 @@
-      
diff --git a/scripts_fortran/energyTr_computation/energyTr_computation_module.f b/scripts_fortran/energyTr_computation/energyTr_computation_module.f
deleted file mode 100644
index 290ea2f..0000000
--- a/scripts_fortran/energyTr_computation/energyTr_computation_module.f
+++ /dev/null
@@ -1,271 +0,0 @@
diff --git a/scripts_fortran/energyTr_computation/extract_energyTr.f b/scripts_fortran/energyTr_computation/extract_energyTr.f
deleted file mode 100644
index a13929c..0000000
--- a/scripts_fortran/energyTr_computation/extract_energyTr.f
+++ /dev/null
@@ -1,69 +0,0 @@
diff --git a/scripts_fortran/energyTr_computation/makefile b/scripts_fortran/energyTr_computation/makefile
deleted file mode 100644
index 8ab1035..0000000
--- a/scripts_fortran/energyTr_computation/makefile
+++ /dev/null
@@ -1,57 +0,0 @@
diff --git a/scripts_fortran/energyTr_computation/test_energyTr_computation.f b/scripts_fortran/energyTr_computation/test_energyTr_computation.f
deleted file mode 100644
index b03c79f..0000000
--- a/scripts_fortran/energyTr_computation/test_energyTr_computation.f
+++ /dev/null
@@ -1,252 +0,0 @@

diff --git a/scripts_py/energyTr_computation/compute_energyTr.py b/scripts_py/energyTr_computation/compute_energyTr.py
deleted file mode 100644
index 8ff6c6b..0000000
--- a/scripts_py/energyTr_computation/compute_energyTr.py
+++ /dev/null
@@ -1,300 +0,0 @@
-#!/usr/bin/python
-
-import sys
-import os
-import getopt
-import subprocess
-import shlex
-import shutil
-
-fortranEnergyTrExe='extract_energyTr'
-
-fortranEnergyTrExePath=os.path.join(os.getenv(
-        'augeanstables'),
-        'scripts_fortran',
-        'energyTr_computation',
-        fortranEnergyTrExe)
-
-
-# error message print
-def print_mg_error(error_mg):
-    sys.stdout.write('****'+error_mg+'**** \n')
-
-
-# progress message print
-def print_mg_progress(mg_progress):
-    '''
-    @description:
-    print a message which is overwritten
-    '''
-    sys.stdout.write('%s\r' % mg_progress)
-    sys.stdout.flush()
-
-
-# final progress message print
-def print_mg_final(mg_progress):
-    '''
-    @description:
-    print a message which is not overwritten
-    '''
-    sys.stdout.write('%s' % mg_progress+'\n')
-    sys.stdout.flush()
-
-
-# display the help for the program
-def display_help():
-    '''
-    @description:
-    display program help
-    '''
-    print ''
-    print 'extract the energy flowing across the domain'
-    print 'borders from netcdf files'
-    print ''
-    print 'options:'
-    print '--------'
-    print '-h (--help)    : display this help'
-    print '-i (--input=)  : main dir with the netcdf files data*.nc'
-    print '-o (--output=) : text file for the output'
-    print ''
-
-
-#parse the input options
-def parse_argv(argv):
-    '''
-    @description:
-    parse the program options
-    '''
-
-    #default values
-    mainDir = 'None'
-
-
-    # store the options and the arguments
-    # in opts, args
-    try:
-        opts, args = getopt.getopt(argv,
-                                   "hi:o:",
-                                   ["help",
-                                    "input=",
-                                    "output="])
-    except getopt.GetoptError:
-        display_help()
-        sys.exit(2)
-
-    if(len(opts)==0):
-        display_help()
-        sys.exit(2)
-
-
-    mainDir = 'None'
-    outputFile = 'None'
-
-    # options
-    for opt, arg in opts:
-
-        if opt in ("-h", "--help"):
-            display_help()
-            sys.exit(2)
-
-        elif opt in ("-i", "--input"):
-            mainDir = arg
-
-        elif opt in ("-o", "--output"):
-            outputFile = arg
-
-
-    # check for directory with the netcdf files
-    if(mainDir=='None'):
-        print_mg_error('directory for netcdf file not provided')
-        display_help()
-        sys.exit(2)
-
-    else:
-        if( not os.path.isdir(mainDir)):
-            print_mg_error(mainDir+' does not exist')
-            display_help()
-            sys.exit(2)
-
-
-    # check for directory where the output file should be saved
-    if(outputFile=='None'):
-        print_mg_error('output path not provided')
-        display_help()
-        sys.exit(2)
-
-    else:
-        if( not os.path.isdir(os.path.dirname(outputFile))):
-            print_mg_error('output dir does not exist')
-            display_help()
-            sys.exit(2)
-    
-    return mainDir, outputFile
-
-
-# determine the netcdf files in the directory
-def find_netcdf_data_files_in_dir(dirPath):
-    '''
-    @description:
-    count the netcdf files in the directory
-    '''
-
-    # list with the netcdf files
-    ncFiles = [name for name in os.listdir(dirPath)\
-                   if (os.path.isfile(os.path.join(dirPath, name)) and\
-                           name.endswith('.nc') and \
-                           name.startswith('data') )]
-
-    # first and last timestep of the netcdf files
-    i_min = int(ncFiles[0].replace('data','').replace('.nc',''))
-    i_max = i_min+len(ncFiles)-1
-
-    return i_min,i_max
-
-
-# generate the fortran executable to extract the
-# energy flowing across the domain borders
-def generate_fortran_exe():
-    '''
-    @description:
-    generate the fortran exe to extract the energy
-    flowing across the domain borders
-    '''
-
-    currentPath = os.getcwd()
-
-    # if the exe does not exist, it should be generated
-    if(not os.path.isfile(fortranEnergyTrExePath)):
-
-        # change dir to where the fortran Exe is generated
-        os.chdir(os.path.dirname(fortranEnergyTrExePath))
-
-        # generate the executable
-        exeOpt = os.getenv('AUGEANSTABLES_PROFILE')
-        os.environ['AUGEANSTABLES_PROFILE']= 'false'
-        cmd='make cleanall && make '+fortranEnergyTrExe+' make clean'
-        subprocess.call(cmd, shell=True)
-        os.environ['AUGEANSTABLES_PROFILE']= exeOpt
-
-        # check whether the executable was generated
-        if( not os.path.isfile(fortranEnergyTrExePath)):
-            print_mg_error('fortran exe not generated: '+fortranEnergyTrExePath)
-            sys.exit(2)
-
-        # change back to the current path
-        os.chdir(currentPath)
-
-    # copy the fortran exe to the current dir
-    shutil.copy(fortranEnergyTrExePath, currentPath)
-
-
-# extract the energy flowing across the domain borders
-# from a netcdf file using fortran exe
-def extract_energyTr(ncFile):
-    '''
-    @description:
-    extract the energy flowing across the domain borders
-    from a netcdf file using fortran exe
-    '''
-
-    # extract the energyTr from output of fortran exe
-    cmd='./'+fortranEnergyTrExe
-    cmd+=" -i "+ncFile
-    args = shlex.split(cmd)
-
-    output = subprocess.Popen(args,stdout=subprocess.PIPE).communicate()[0]
-    
-    # convert to float
-    try :
-        energyTr= float(output.replace('energyTr:',''))
-
-    except ValueError:
-
-        print_mg_error('error when extracting energyTr')
-        print_mg_error('fortranEnergyTrExe: '+fortranEnergyTrExe)
-        print_mg_error('ncFile: '+ncFile)
-        print_mg_error('output: '+output)
-        sys.exit(2)
-
-    return energyTr
-
-
-# extract the time from a netcdf file using ncdump
-def extract_time(ncFile):
-    '''
-    @description:
-    extract the time from netcdf file using
-    ncdump command
-    '''
-
-    # extract the energyTr from output of fortran exe
-    cmd='ncdump -v time '+ncFile
-    args = shlex.split(cmd)
-    output = subprocess.Popen(args,stdout=subprocess.PIPE).communicate()[0]
-    output = output.split('\n')[-3]
-
-    # convert to float
-    try :
-        time= float(output.replace('time = ','').replace(';',''))
-    
-    except ValueError:
-    
-        print_mg_error('error when extracting time')
-        print_mg_error('ncFile: '+ncFile)
-        print_mg_error('output: '+output)
-        sys.exit(2)
-
-    return time
-
-
-if __name__=="__main__":
-
-    # extract the options from the command line
-    mainDir, outputFile = parse_argv(sys.argv[1:])
-
-
-    # determine the number of netcdf files in dir
-    tmin,tmax = find_netcdf_data_files_in_dir(mainDir)
-
-
-    # initialize the output file
-    if(os.path.isfile(outputFile)):
-        os.remove(outputFile)
-
-
-    # generate the fortran exe to extract the
-    # energy flowing across the domain borders
-    generate_fortran_exe()
-
-
-    # start the extraction of the energy flowing
-    # across the domain borders
-    mg_progress = 'extract energyTr: ...'
-    print_mg_progress(mg_progress)
-
-
-    # extract the energy flowing though the domain
-    # borders for all netcdf files in the directory
-    out = open(outputFile, 'w')
-
-    for t in range(tmin,tmax+1):
-
-        ncFile = os.path.join(mainDir,'data'+str(t)+'.nc')
-
-        time     = extract_time(ncFile)
-        energyTr = extract_energyTr(ncFile)
-
-        out.write("%i %f %f\n" % (t,time,energyTr))
-
-        mg_progress = 'extract energyTr: '+str(t-tmin+1)+' / '+str(tmax-tmin+1)
-        print_mg_progress(mg_progress)
-        
-    mg_progress = 'extract energyTr: done       '
-    print_mg_final(mg_progress)
-
-    out.close()
-
-
-    # remove the fortran exe
-    os.remove(fortranEnergyTrExe)
-    
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/automatization_contours_csts.py b/scripts_py/wall_steady_state_automatization/contours_extraction/automatization_contours_csts.py
deleted file mode 100644
index cbff160..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/automatization_contours_csts.py
+++ /dev/null
@@ -1,44 +0,0 @@
-#!/usr/bin/python
-
-import sys
-import os
-import inspect
-
-'''
-@description
-automatization constants used to determine the bubble
-contours
-'''
-
-cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(\
-    os.path.split(
-    inspect.getfile( inspect.currentframe() ))[0],"../../sm_lg_domain_automatization")))
-if cmd_subfolder not in sys.path:
-    sys.path.insert(0, cmd_subfolder)
-
-from create_sm_lg_inputs import get_parameter
-
-from library_sm_lg_inputs import (get_we,
-                                  get_cv_r)
-
-# extract length_c, dim2d_a, dim2d_b, dim2d_M, dim2d_cv, dim2d_R
-# and dim2d_K from the dim2d_parameters.f fortran file
-dim2dParamPath = os.path.join(os.getenv('augeanstables'),
-                              'src',
-                              'physical_models',
-                              'dim2d',
-                              'dim2d_parameters.f')
-
-length_c  = float(get_parameter('length_c', dim2dParamPath))
-dim2d_a   = float(get_parameter( 'dim2d_a', dim2dParamPath))
-dim2d_b   = float(get_parameter( 'dim2d_b', dim2dParamPath))
-dim2d_M   = float(get_parameter( 'dim2d_M', dim2dParamPath))
-dim2d_cv  = float(get_parameter('dim2d_cv', dim2dParamPath))
-dim2d_R   = float(get_parameter( 'dim2d_R', dim2dParamPath))
-dim2d_K   = float(get_parameter( 'dim2d_K', dim2dParamPath))
-
-# compute the reduced cv_r
-cv_r = get_cv_r(dim2d_M,dim2d_cv,dim2d_R)
-
-# compute the Weber number
-we = get_we(length_c, dim2d_a, dim2d_b, dim2d_M, dim2d_K)
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/contours.visit b/scripts_py/wall_steady_state_automatization/contours_extraction/contours.visit
deleted file mode 100644
index f9e27b6..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/contours.visit
+++ /dev/null
@@ -1,3 +0,0 @@
-!NBLOCKS 2
-contours.0.vtk
-contours.1.vtk
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_detachment_graphs.py b/scripts_py/wall_steady_state_automatization/contours_extraction/draw_detachment_graphs.py
deleted file mode 100644
index 2a61f30..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_detachment_graphs.py
+++ /dev/null
@@ -1,196 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description
-draw graphs characteristic for the study of detachment of
-a spherical cap approximation of a vapor bubble by the flow
-
-time at which the vapor bubble is detached from the wall
-maximum extent of the bubble when the bubble is detached
-mass inside the bubble at the detachment time
-'''
-
-import os
-import sys
-import numpy as np
-import matplotlib.pyplot as plt
-from library_contours_graph import grayscale_to_RGB
-from library_contours_detachment import (find_detachment_time,
-                                         find_bubble_extent)
-    
-
-def generate_detachment_data(
-    simDir,
-    legend='None',
-    width=3,
-    xlabel='',
-    ylabel='',
-    figPath=''):
-    '''
-    @description:
-    determine the detachment time, draw the contour
-    of the vapor bubble at the detachment time and
-    compute the maximum extent of the bubble when
-    it detaches from the wall
-    '''
-
-
-    #============================================================
-    # determine the time at which the bubble detaches from the
-    # wall using the contact length as function of time
-    #============================================================
-    contactLghPath = os.path.join(simDir,'contact_lgh.txt')
-
-    if( not os.path.isfile(contactLghPath)):
-        print 'draw_detachment_graphs'
-        print 'generate_detachment_data'
-        print 'contact length file not found:'
-        print contactLghPath
-        sys.exit(2)
-
-    else:
-        (det,i_det,t_det) = find_detachment_time(contactLghPath)
-        print det
-        
-    if(not det):
-        print 'no detachment'
-        return (0.0,0.0,0.0,0.0)
-
-    #============================================================
-    # extract the vapour data in the bubble at the detachment
-    #============================================================
-    massPath = os.path.join(simDir,'mass.txt')
-
-    if( not os.path.isfile(massPath)):
-        print 'draw_detachment_graphs'
-        print 'generate_detachment_data'
-        print 'mass file not found:'
-        print massPath
-        sys.exit(2)
-
-    else:
-        mass = np.loadtxt(massPath)
-        for i in range(0,len(mass[:,0])):
-            if(mass[i,0]==i_det):
-                mass_det = mass[i,2]
-                break
-
-
-    #============================================================
-    # extract the data describing the contour of the bubble
-    # at the detachment time
-    #============================================================
-    contourDataPath = os.path.join(simDir,'contours'+str(i_det)+'.curve')
-
-    if( not os.path.isfile(contourDataPath)):
-        print 'draw_detachment_graphs'
-        print 'generate_detachment_data'
-        print 'contour data file not found:'
-        print contourDataPath
-        sys.exit(2)
-
-    else:
-        contourData = np.loadtxt(contourDataPath)
-
-
-    #============================================================
-    # extract the x-coordinate where the bubble detach
-    #============================================================
-    y = np.array(contourData[:,1])
-    i_min, = np.unravel_index(y.argmin(),y.shape)
-    x_det = contourData[i_min,0]
-
-    
-    #============================================================
-    # extract the maximum extent of the bubble at detachment
-    # time using the contour at this time
-    #============================================================
-    (max_length,segment_pts) = find_bubble_extent(contourData)
-    
-
-    #============================================================
-    # plot the contour of the bubble at detachment time as well
-    # as the segment for the maximum extent of the bubble
-    #============================================================
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-
-    ax = fig.add_subplot(111)
-
-    plt.plot(contourData[:,0],
-             contourData[:,1],
-             '+-',
-             linewidth=width,
-             color='black')
-
-    plt.plot(segment_pts[:,0],
-             segment_pts[:,1],
-             '--',
-             linewidth=width,
-             color='black')
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-    if(not figPath==''):
-        plt.savefig(figPath)
-
-    return (t_det,x_det,max_length,mass_det)
-
-
-if __name__=='__main__':
-
-    mainDir = os.path.join(os.getenv('HOME'),
-                           'projects')
-
-    #=============================================================
-    # Detachment study at different contact angle and flow
-    # velocities
-    #=============================================================
-
-    # directories for the detachment study
-    # with different contact angles
-    contactAngleArray = [45.0] #,45.0,67.5,90.0,112.5,135.0]
-    flowVelocityArray = [0.1,0.2,0.3,0.4,0.5]
-
-    simDirs = []
-
-    for contactAngle in contactAngleArray:
-        for flowVelocity in flowVelocityArray:
-
-
-            # directory analyzed
-            #=================================================================
-            simDir = os.path.join(
-                '20150708_dim2d_0.95_ca22.5-135.0_vap_vl0.1-0.5_hca0.0_sph',
-                'dim2d_0.95_ca'+str(contactAngle)+'_vap_vl'+str(flowVelocity)+'_hca0.0_sph')
-
-
-            # generate the detachement data corresponding to the simulation
-            #=================================================================
-            # detachment time: time at which the bubble makes a closed contour
-            #                  seperated from the wall
-            # x-coord        : x-coordinate of the lowest point of the bubble
-            #                  contour
-            # max_lgh        : maximum extent of the bubble at detachment time
-            # mass           : vapor mass contained in the bubble at detachment
-            #                  time
-            #=================================================================
-            (t_det,x_det,lgh_det,mass_det) = generate_detachment_data(os.path.join(mainDir,simDir,'contours'))
-
-            print '=================================================='
-            print 'contact_angle: ', contactAngle
-            print 'flow_velocity: ', flowVelocity
-            print '=================================================='
-            print 'detachment data'
-            print ("time   :  %3.2f" % (t_det))
-            print ("x-coord:  %4.3f"  % (x_det))
-            print ("max_lgh:  %4.2f"  % (lgh_det))
-            print ("mass   :  %4.3f"  % (mass_det))
-            print ''
-
-    plt.show()
-
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_graphs.py b/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_graphs.py
deleted file mode 100644
index a3b9de6..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_graphs.py
+++ /dev/null
@@ -1,664 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description
-draw graphs characteristic for the study of bubble nucleation:
-
-initial time when the bubble appears, at different fluxes
-initial mass when the bubble appears, at different fluxes
-mass = f(t), at different fluxes
-
-initial time when the bubble appears, at different contact angles
-initial mass when the bubble appears, at different contact angles
-mass = f(t), at different contact angles
-'''
-
-import os
-import numpy as np
-import matplotlib.pyplot as plt
-from library_contours_graph import grayscale_to_RGB
-from math import sqrt
-
-
-def compute_latent_heat(T):
-    '''
-    @description: approximate the latent close to the critical
-    temperature
-    '''
-
-    return 15.08*sqrt(1.0-T)
-
-
-def get_nucleation_qties(simDirs):
-
-    l = len(os.path.basename(os.path.dirname(simDirs[0])))
-    for i in range(1,len(simDirs)):
-        l1 = len(os.path.basename(os.path.dirname(simDirs[i])))
-        if(l1>l):
-            l=l1
-
-    format  = "%"+str(l)+"s | %11s | %20s"
-    format2 = "%"+str(l)+"s | %4.2f - %4.2f | %3.2e - %3.2e"
-
-    print ''
-    print(format % ('sim_dir', 'time', 'mass'))
-    print(format % ('----------------', '-----------', '--------------------'))
-
-    time = []
-
-    for i in range(0,len(simDirs)):
-        
-        mass = np.loadtxt(os.path.join(simDirs[i],'mass.txt'))
-
-        for j in range(0,len(mass[:,0])):
-            if(mass[j,2]>0):
-                dt = 0.5*(mass[j+1,1]-mass[j,1])
-                dm = 0.5*(mass[j+1,2]-mass[j,2])
-                print(format2 % (os.path.basename(os.path.dirname(simDirs[i])), mass[j,1], dt, mass[j,2], dm))
-
-                time.append(mass[j,1])
-                break
-
-    print ''
-    print ''
-
-    return time,
-
-
-def create_mass_graph(simDirs,
-                      legend='None',
-                      width=3,
-                      xlabel='',
-                      ylabel='',
-                      show=True,
-                      figPath='',
-                      add_zoom_above=False,
-                      add_linear_interpolation=True,
-                      borders_linear_interpolation='None',
-                      step=1,
-                      legendLoc='lower right',
-                      styleDashed=False,
-                      xlim='None',
-                      ylim='None'):
-    '''
-    @description: create a graph with the vapor mass
-    as function of time for different contact angles
-    '''
-
-    growthRate='None'
-
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-
-
-    # plot the mass as function of time
-    # as the main plot
-    ax = fig.add_subplot(111)
-
-    ini_time = [100.,0.]
-    ini_mass = [0.,0.]
-
-    start_i = np.empty([len(simDirs)])
-    end_i   = np.empty([len(simDirs)])
-
-    max_mass = 0.0
-
-    for i in range(0,len(simDirs)):
-        
-        mass = np.loadtxt(os.path.join(simDirs[i],'mass.txt'))
-
-        max_mass = max(max_mass,max(mass[:,2]))
-
-        # determine the last relevant step: timestep!=0
-        start_i[i]=0
-        for j in range(0,len(mass[:,0])):
-            if(mass[j,2]>0.0):
-                start_i[i]=j
-                break
-
-        end_i[i]=len(mass[:,0])-1
-        for j in range(int(start_i[i]),len(mass[:,0])):
-            if(mass[j,0]==0.0):
-                end_i[i]=j-1
-                break
-
-        # extract the initial time when
-        # the bubble appears
-        for j in range(0,len(mass[:,0])):
-
-            if(mass[j,2]>0.0):
-                ini_time[0] = min(ini_time[0],mass[j,1])
-                ini_time[1] = max(ini_time[1],mass[j,1])
-                ini_mass[0] = min(ini_mass[0],mass[j,2])
-                ini_mass[1] = max(ini_mass[1],mass[j,2])
-                break
-
-        # plot the mass as function
-        # of time on the main graph
-        if(styleDashed):
-            grayscale_value = 0.2+ 0.8*float((i-i%2)/2.0)/float(len(simDirs)/2.0)
-        else:
-            grayscale_value = 0.2+ 0.8*float(i)/float(len(simDirs))
-        
-        if(styleDashed):
-            if(i%2==0):
-                style='-'
-            else:
-                style='--'
-        else:
-            style='-'
-
-        plt.plot(mass[0:end_i[i]:step,1],
-                 mass[0:end_i[i]:step,2],
-                 style,
-                 linewidth=width,
-                 color=grayscale_to_RGB(grayscale_value))
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-
-    # extract the linear growth rate
-    if(add_linear_interpolation):
-
-        growthRate = []
-
-        if(borders_linear_interpolation!='None'):
-        
-            for i in range(0,len(simDirs)):
-
-                mass = np.loadtxt(os.path.join(simDirs[i],'mass.txt'))
-
-                for j in range(0,len(borders_linear_interpolation[i])):
-                    
-                    i1 = borders_linear_interpolation[i][j][0]
-                    i2 = borders_linear_interpolation[i][j][1]
-                    
-                    xi = mass[i1:i2,1]
-                    A  = np.array([xi, np.ones(len(xi))])
-                    yi = mass[i1:i2,2]
-                    
-                    pi = np.linalg.lstsq(A.T,yi)[0] #least square approximation
-                    xi = mass[i1-5:i2+5,1]
-                    line = pi[0]*xi + pi[1]
-
-                    if(len(borders_linear_interpolation[i])>1 and j==0):
-                        style = '--'
-                    else:
-                        style ='-'
-                        growthRate.append(pi[0])
-
-                    plt.plot(xi,line,'r',linestyle=style)
-                    
-                    print("%40s | growthrate: %3.2e" % (os.path.basename(os.path.dirname(simDirs[i])), pi[0]))
-
-        else:
-
-            for i in range(0,len(simDirs)):
-
-                mass = np.loadtxt(os.path.join(simDirs[i],'mass.txt'))
-                
-                xi = mass[int(start_i[i]):int(end_i[i]),1]
-                A  = np.array([xi, np.ones(len(xi))])
-                yi = mass[int(start_i[i]):int(end_i[i]),2]
-            
-                pi = np.linalg.lstsq(A.T,yi)[0] #least square approximation
-                line = pi[0]*xi + pi[1]
-                plt.plot(xi,line,'r-')
-
-                print("%40s | growthrate: %3.2e" % (os.path.basename(os.path.dirname(simDirs[i])), pi[0]))
-                growthRate.append(pi[0])
-
-    if(add_zoom_above):
-        ax.set_ylim(0.0,max_mass*(1.0+0.2))
-    else:
-        ax.set_ylim(0.0,max_mass)
-
-    if(xlim!='None'):
-        ax.set_xlim(xlim[0],xlim[1])
-
-    if(ylim!='None'):
-        ax.set_ylim(ylim[0],ylim[1])
-
-    if(legend!='None'):
-        plt.legend(legend,loc=legendLoc)
-
-    # add a zoom where the initial bubble appears
-    # on the lower right part of the plot
-    if(add_zoom_above):
-        ax_x_lim = ax.get_xlim()
-        ax_y_lim = ax.get_ylim()
-
-        border = 0.2*(ini_time[1]-ini_time[0])
-
-        ini_time[0]-= border
-        ini_time[1]+= border
-        
-        ini_mass[0] = ini_mass[0]*(1.-0.1)
-        ini_mass[1] = ini_mass[0]+(ini_time[1]-ini_time[0])*(ax_y_lim[1]-ax_y_lim[0])/(ax_x_lim[1]-ax_x_lim[0])
-        
-        width    = 0.5
-        height_p = width*((ini_mass[1]-ini_mass[0])/(ax_y_lim[1]-ax_y_lim[0]))/((ini_time[1]-ini_time[0])/(ax_x_lim[1]-ax_x_lim[0]))
-        height   = 0.2
-        
-        ini_mass[1] = height/height_p*ini_mass[1]
-        
-        ax_zoom = plt.axes([.15, .65, width, height]) #, axisbg='y')
-        for i in range(0,len(simDirs)):
-        
-            mass = np.loadtxt(os.path.join(simDirs[i],'mass.txt'))
-        
-            grayscale_value = 0.2+ 0.8*float(i)/float(len(simDirs))
-        
-            p = ax_zoom.plot(mass[0:end_i[i]:step,1],
-                         mass[0:end_i[i]:step,2],
-                         '+-',
-                         linewidth=5*width,
-                         color=grayscale_to_RGB(grayscale_value))
-            plt.setp(ax_zoom, xticks=[], yticks=[])
-        
-        ax_zoom.set_xlim(ini_time[0],ini_time[1])
-        ax_zoom.set_ylim(ini_mass[0],ini_mass[1])
-
-    if(show):
-        plt.show()
-        plt.close()
-
-    if(not figPath==''):
-        plt.savefig(figPath)
-
-    return growthRate,
-
-
-def create_growthrate_graph(heatFlux,
-                            growthRate,
-                            width=3,
-                            xlabel='',
-                            ylabel='',
-                            show=True,
-                            legend='None',
-                            xlim='None',
-                            ylim='None'):
-    '''
-    @description: draw a graph with the mass growth rate
-    as a function of the heat flux
-    '''
-
-
-    # open new figure for the mass growth rate
-    plt.close("all")
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-    ax = fig.add_subplot(111)
-
-
-    # plot the mass growth rate
-    plt.plot(heatFlux,
-             growthRate,
-             'o',
-             linewidth=width,
-             color=grayscale_to_RGB(0.8))
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-
-    # add the linear interpolation
-    xi = np.array(heatFlux)
-    A  = np.array([xi, np.ones(len(xi))])
-    yi = np.array(growthRate)
-
-    pi = np.linalg.lstsq(A.T,yi)[0] #least square approximation
-    xi = np.insert(xi,0,0.0)
-    xi = np.append(xi,0.11)
-    line = pi[0]*xi + pi[1]
-
-    plt.plot(xi,line,'r-')
-
-    plt.plot([-pi[1]/pi[0]],[0.0],'rs')
-    plt.plot([0.0,0.11],[0.0,0.0],'k--')
-
-    print 'equivalent_latent_heat: ', pi[0]
-    print 'equivalent_temperature: ', 1.0 - (pi[0]/15.08)**2
-
-
-    # graph properties
-    if(xlim!='None'):
-        ax.set_xlim(xlim[0],xlim[1])
-
-    if(ylim!='None'):
-        ax.set_ylim(ylim[0],ylim[1])
-
-    if(legend!='None'):
-        plt.legend(legend,loc=legendLoc)
-
-
-    # show the graph
-    if(show):
-        plt.show()
-
-
-def create_temperature_graph(simDirs,
-                             legend='None',
-                             width=3,
-                             xlabel='',
-                             ylabel='',
-                             show=True,
-                             figPath='',
-                             borders='None',
-                             legendLoc='lower right',
-                             xlim='None',
-                             ylim='None'):
-    '''
-    @description: create a graph with the temperature
-    at the interface for different conditions
-    '''
-
-
-    # figure initialization
-    plt.close("all")
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-    ax = fig.add_subplot(111)
-
-
-    for i in range(0,len(simDirs)):
-        
-        temperature = np.loadtxt(os.path.join(simDirs[i],'temperature.txt'))
-
-
-        # data plotted
-        if(borders!='None'):
-            i_start = borders[i][0]
-            i_end   = borders[i][1]
-        else:
-            
-            for j in range(0,len(temperature[:,0])):
-                if(temperature[j,1]>0):
-                    i_start = j
-                    break
-
-            for j in range(len(temperature[:,0])-1,0,-1):
-                if(temperature[j,1]>0):
-                    i_end = j
-                    break
-
-        # color
-        grayscale_value = 0.2+ 0.8*float(i)/float(len(simDirs))
-        
-        # plot
-        plt.plot(temperature[i_start:i_end,1],
-                 temperature[i_start:i_end,2],
-                 '-',
-                 linewidth=width,
-                 color=grayscale_to_RGB(grayscale_value))
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-
-    # graph properties
-    if(xlim!='None'):
-        ax.set_xlim(xlim[0],xlim[1])
-
-    if(ylim!='None'):
-        ax.set_ylim(ylim[0],ylim[1])
-
-    if(legend!='None'):
-        plt.legend(legend,loc=legendLoc)
-
-
-    # show the graph
-    if(show):
-        plt.show()
-
-
-def compute_phase_transition_energy_supplied_rate(
-    simDirs,
-    heat_flux,
-    mass_growthRate,
-    borders):
-    '''
-    @description: compute the ratio of energy between the
-    heat for the phase transion and the heat supplied by
-    the wall
-    '''
-    
-    print heat_flux
-    print mass_growthRate
-
-    for i in range(0,len(heat_flux)):
-
-        temperature = np.loadtxt(os.path.join(simDirs[i],'temperature.txt'))
-	
-	# computation of the latent heat in the
-	# phase change for the entire simulation
-	latent_heat = 0.0
-        T_av = 0.0
-
-	for j in range(borders[i][0],borders[i][1]):
-	    T = temperature[j,2]
-	    latent_heat+= compute_latent_heat(T)
-            T_av+= T
-	
-	# average latent heat: latent heat power per unit mass
-	latent_heat /= float(borders[i][1]-borders[i][0])
-        T_av        /= float(borders[i][1]-borders[i][0])
-	
-	# average latent heat
-	latent_heat*= mass_growthRate[i]
-
-        # equivalent temperature
-        print 'borders: ', borders[i][0],borders[i][1]
-        print 'av_temperature: ', T_av
-        print 'eq_temperature: ', 1.0 - (latent_heat/15.08)**2
-        print 'mass_growth_rate: ', mass_growthRate[i]
-        print 'latent_heat: ', latent_heat/mass_growthRate[i]
-        print 'Q_latent_heat: ', latent_heat
-
-	# ratio of heat for the phase transition and
-	# the heat provided by the wall
-	ratio = latent_heat/heat_flux[i]
-	
-	print 'heat_flux: ', heat_flux[i], 'ratio phase_transition/wall: ', ratio
-
-
-if __name__=='__main__':
-
-    mainDir = os.path.join(os.getenv('HOME'),
-                           'projects')
-
-
-    #=============================================================
-    # Options for the postprocessing graphs for the nucleation
-    # on a uniform surface
-    #=============================================================
-    draw_angle_mass_graph = False
-    draw_flux_mass_graph  = False
-    draw_angle_temperature_graph = False
-    draw_flux_temperature_graph = False
-    compute_angle_heat_ratio = True
-    compute_flux_heat_ratio = False
-
-    
-    #=============================================================
-    # Nucleation study at different contact angles
-    #=============================================================
-
-    # directories for the nucleation study
-    # with different contact angles
-    contactAngleArray = [22.5,45.0,67.5,90.0,112.5,135.0]
-    
-    simDirs = []
-    
-    for contactAngle in contactAngleArray:
-        
-        simDir = 'dim2d_0.95_ca'+str(contactAngle)+'_vap'+'_fh0.02'
-        simDirs.append(os.path.join(mainDir,simDir,'contours'))
-    
-    
-    borders_linear_interpolation = []
-    borders_linear_interpolation.append([[80,215]])
-    borders_linear_interpolation.append([[80,215]])
-    borders_linear_interpolation.append([[70,215]])
-    borders_linear_interpolation.append([[50,215]])
-    borders_linear_interpolation.append([[30,215]])
-    borders_linear_interpolation.append([[20,170]])
-
-
-    if(draw_angle_mass_graph or compute_angle_heat_ratio):
-    	
-    	# draw a graph with the mass = f(t) for the different simulations
-    	growthRate, = create_mass_graph(simDirs,
-    	                                legend=contactAngleArray,
-    	                                width=3,
-    	                                xlabel='$t$',
-    	                                ylabel='$m_v(t)$',
-    	                                show=draw_angle_mass_graph,
-    	                                add_zoom_above=True,
-    	                                borders_linear_interpolation=borders_linear_interpolation,
-    	                                ylim=[0,0.0155])
-    	
-    	# extract time+mass nucleation
-    	time, = get_nucleation_qties(simDirs)
-
-
-    # create a graph with the temperature at the interface
-    if(draw_angle_temperature_graph):
-
-        borders = []
-        for i in range(0,len(borders_linear_interpolation)):
-
-            if(len(borders_linear_interpolation[i])>1):
-                borders.append(borders_linear_interpolation[i][1])
-            else:
-                borders.append(borders_linear_interpolation[i][0])
-
-        create_temperature_graph(simDirs,
-                                 legend=contactAngleArray,
-                                 legendLoc='upper right',
-                                 width=3,
-                                 xlabel='$t$',
-                                 ylabel='$T(t)$',
-                                 show=True,
-                                 borders=borders)
-
-
-    # computation of the ratio of heat used
-    # for the phase transition and the total
-    # heat flux provided
-    if(compute_angle_heat_ratio):
-
-        heat_flux = 0.02*np.ones(len(simDirs))
-        mass_growthRate = growthRate #for fh \in [0.02,0.04]
-
-        borders = []
-        for limits in borders_linear_interpolation:
-            borders.append(limits[0])
-    
-        compute_phase_transition_energy_supplied_rate(
-            simDirs,
-            heat_flux,
-            mass_growthRate,
-            borders)
-
-
-    #=============================================================
-    # Nucleation study at different flux intensities
-    #=============================================================
-
-    # directories for the nucleation study
-    # with different contact angles
-    heatFluxArray    = [ 0.02, 0.04, 0.06, 0.08, 0.1]
-    heatFluxArrayLeg = [ 0.02, 0.04, 0.06, 0.08, 0.1]
-
-    simDirs = []
-
-    for heatFlux in heatFluxArray:
-
-        simDir = 'dim2d_0.95_ca90.0_vap_fh'+str(heatFlux)
-        simDirs.append(os.path.join(mainDir,simDir,'contours'))
-
-    borders_linear_interpolation = []
-    borders_linear_interpolation.append([[50,70],[60,215]])
-    borders_linear_interpolation.append([[15,30],[20,110]])
-    borders_linear_interpolation.append([[10,40]])
-    borders_linear_interpolation.append([[5,15]])
-    borders_linear_interpolation.append([[4,8]])
-
-
-    if(draw_flux_mass_graph or compute_flux_heat_ratio):
-
-        # draw a graph with the mass = f(t) for the different flux
-        growthRate, = create_mass_graph(simDirs,
-                                        legend=heatFluxArrayLeg,
-                                        width=3,
-                                        xlabel='$t$',
-                                        ylabel='$m(t)$',
-                                        show=draw_flux_mass_graph,
-                                        add_zoom_above=True,
-                                        borders_linear_interpolation=borders_linear_interpolation)
-
-        # extract time+mass nucleation
-        time, = get_nucleation_qties(simDirs)
-
-
-    # create a graph with the heat flux and the growth rate
-    #create_growthrate_graph(heatFluxArray,
-    #                        growthRate,
-    #                        width=3,
-    #                        xlabel='$Q_{w,m}$',
-    #                        ylabel='$\dot{m}$',
-    #                        show=True,
-    #                        xlim=[0,0.11])
-
-
-    # create a graph with the temperature at the interface
-    if(draw_flux_temperature_graph):
-
-        borders = []
-        for i in range(0,len(borders_linear_interpolation)):
-
-            if(len(borders_linear_interpolation[i])>1):
-                borders.append(borders_linear_interpolation[i][1])
-            else:
-                borders.append(borders_linear_interpolation[i][0])
-
-        create_temperature_graph(simDirs,
-                                 legend=heatFluxArrayLeg,
-                                 legendLoc='upper right',
-                                 width=3,
-                                 xlabel='$t$',
-                                 ylabel='$T(t)$',
-                                 show=True,
-                                 borders=borders)
-    
-    #for i in range(0,len(heatFluxArray)):
-    #    
-    #    print 'heat_flux: ', heatFluxArray[i], 'Q*t: ', heatFluxArray[i]*time[i]
-      
-
-    # computation of the ratio of heat used
-    # for the phase transition and the total
-    # heat flux provided
-    if(compute_flux_heat_ratio):
-
-        #heat_flux = heatFluxArray[0:2]    #for fh \in [0.02,0.04]
-        #mass_growthRate = growthRate[0:2] #for fh \in [0.02,0.04]
-        #borders = [[60,215],[20,110]]
-
-        heat_flux = heatFluxArray    #for fh \in [0.02,0.04]
-        mass_growthRate = growthRate #for fh \in [0.02,0.04]
-        borders = [[60,215],[20,110],[10,40],[5,15],[4,8]]
-    
-        compute_phase_transition_energy_supplied_rate(
-            simDirs,
-            heat_flux,
-            mass_growthRate,
-            borders)
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_inflow_graphs.py b/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_inflow_graphs.py
deleted file mode 100644
index a556c81..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_inflow_graphs.py
+++ /dev/null
@@ -1,452 +0,0 @@
-#!/usr/bin/python
-
-from draw_nucleation_graphs import create_mass_graph, get_nucleation_qties
-from library_contours_graph import create_st_graph
-import os
-import numpy as np
-import matplotlib.pyplot as plt
-from library_contours_graph import grayscale_to_RGB
-
-
-def create_nucleation_time_graph(dirs,
-                                 velocities,
-                                 styles,
-                                 legend='None',
-                                 legendLoc='lower right',
-                                 width=3,
-                                 xlabel='$v$',
-                                 ylabel='$t_n$',
-                                 bothDirs=False,
-                                 show=True):
-    '''
-    @description: create a graph with the nucleation times
-    for different velocities and fluxes
-    
-    - dirs   : 2D array containing the directory paths
-    - styles : array with the style corresponding to dirs[i]
-    - leg    : legend for dirs[i]
-    - width  : width of the lines
-    - xlabel : xlabel for the plot
-    - ylabel : ylabel for the plot
-    - show   : show the plot at the end
-    '''
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-    ax = fig.add_subplot(111)
-
-    i=0
-
-    for simDirs,simVelocities,simStyle in zip(dirs,velocities,styles):
-
-        # determine the color for the plot
-        if(bothDirs):
-            grayscale_value = 0.2+ 0.8*float(i%(len(dirs)/2))/float(len(dirs)/2)
-        else:
-            grayscale_value = 0.2+ 0.8*float(i)/float(len(dirs))
-        simColor = grayscale_to_RGB(grayscale_value)        
-
-        # array containing the data at fixed flux
-        x_data = []
-        y_data = []
-
-        for simDir,simVelocity in zip(simDirs,simVelocities):
-
-            # get the nucleation time and mass
-            mass = np.loadtxt(os.path.join(simDir,'contours','mass.txt'))
-            for j in range(0,len(mass[:,0])):
-                if(mass[j,2]>0):
-                    nucleation_time = mass[j,1]
-                    nucleation_mass = mass[j,2]
-                    break
-
-            # extract the velocity corresponding to the directory
-            # it is simVelocity
-
-            # create the corresponding database for plotting
-            x_data.append(simVelocity)
-            y_data.append(nucleation_time)
-
-        # plot the data
-        plt.plot(x_data,
-                 y_data,
-                 simStyle,
-                 linewidth=width,
-                 color=simColor)
-
-        i+=1
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-    if(legend!='None'):
-        plt.legend(legend,loc=legendLoc)
-
-    if(show):
-        plt.show()
-        plt.close()
-
-
-def create_nucleation_time_graph2(dirsPar,
-                                  dirsLin,
-                                  velocities,
-                                  styles,
-                                  legend='None',
-                                  legendLoc='lower right',
-                                  width=3,
-                                  xlabel='$v$',
-                                  ylabel='$t_n$',
-                                  show=True):
-    '''
-    @description: create a graph with the nucleation times
-    for different velocities and fluxes
-    
-    - dirs   : 2D array containing the directory paths
-    - styles : array with the style corresponding to dirs[i]
-    - leg    : legend for dirs[i]
-    - width  : width of the lines
-    - xlabel : xlabel for the plot
-    - ylabel : ylabel for the plot
-    - show   : show the plot at the end
-    '''
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-    ax = fig.add_subplot(111)
-
-    i=0
-
-    for simDirsPar,simDirsLin,simVelocities,simStyle in zip(dirsPar,dirsLin,velocities,styles):
-
-        # determine the color for the plot
-        grayscale_value = 0.2+ 0.8*float(i)/float(len(dirs))
-        simColor = grayscale_to_RGB(grayscale_value)        
-
-        # array containing the data at fixed flux
-        x_data = []
-        y_data = []
-
-        for simDirPar,simDirLin,simVelocity in zip(simDirsPar,simDirsLin,simVelocities):
-
-            # get the nucleation time and mass: parabolic
-            mass = np.loadtxt(os.path.join(simDirPar,'contours','mass.txt'))
-            for j in range(0,len(mass[:,0])):
-                if(mass[j,2]>0):
-                    nucleation_time = mass[j,1]
-                    nucleation_mass = mass[j,2]
-                    break
-
-            # create the corresponding database for plotting
-            x_data_par.append(simVelocity)
-            y_data_par.append(nucleation_time)
-
-            
-            # get the nucleation time and mass: linear
-            mass = np.loadtxt(os.path.join(simDirLin,'contours','mass.txt'))
-            for j in range(0,len(mass[:,0])):
-                if(mass[j,2]>0):
-                    nucleation_time = mass[j,1]
-                    nucleation_mass = mass[j,2]
-                    break
-
-            # create the corresponding database for plotting
-            x_data_par.append(simVelocity)
-            y_data_par.append(nucleation_time)
-
-        # plot the data
-        plt.plot(x_data_par,
-                 y_data_par,
-                 simStyle+'-',
-                 linewidth=width,
-                 color=simColor)
-
-        plt.plot(x_data_lin,
-                 y_data_lin,
-                 simStyle+'-',
-                 linewidth=width,
-                 color=simColor)
-
-        i+=1
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-    if(legend!='None'):
-        plt.legend(legend,loc=legendLoc)
-
-    if(show):
-        plt.show()
-        plt.close()
-
-
-if __name__=='__main__':
-    
-    drawNucleationInflowPar = True  #v \in \{0.1-0.5/}, fh=0.04 (parabolic)
-    drawNucleationInflowLin = True  #v \in \{0.1-0.5/}, fh=0.04 (linear)
-    drawNucleationFluxPar   = True  #v \in \{0.2,0.4/}, fh\in\{0.04,0.1/} (parabolic)
-    drawNucleationFluxLin   = True  #v \in \{0.2,0.4/}, fh\in\{0.04,0.1/} (linear)
-
-    drawNucleationTimePar = False
-    drawNucleationTimeLin = False
-
-    mainDir = os.path.join(os.getenv('HOME'),
-                           'projects')    
-    
-    # directories for the nucleation study with
-    # different contact angles
-    contactAngle = 22.5
-    heatFlux = 0.04
-    velocityArray    = [0.0,0.1,0.2,0.3,0.4,0.5]
-
-    velocityLegArrayPar = ['0.0','0.1','0.2','0.3','0.4','0.5']
-    velocityLegArrayLin = velocityLegArrayPar
-    
-    heatFluxArray    = [0.04,0.05,0.06,0.08,0.1]
-    heatFluxLegArray = [0.04,0.05,0.06,0.08,0.1]
-
-    simDirsPar = []
-    simDirsLin = []
-    
-    
-    # directories for the simulations with the linear
-    # or parabolic profiles and nucleation: varying velocity
-    if(drawNucleationInflowPar or drawNucleationInflowLin):
-
-        for velocity in velocityArray:
-    
-            simDir = 'dim2d_0.95_ca'+str(contactAngle)+\
-                '_vap'+\
-                '_fh'+str(heatFlux)
-
-            simPathPar = simDir
-            simPathLin = simDir
-            
-            if(velocity!=0.0):
-                simPathPar+='_v'+str(velocity)            
-                simPathLin+='_vl'+str(velocity)
-
-            simPathPar+='_hca0.0'
-            simPathLin+='_hca0.0'
-
-            simDirsPar.append(os.path.join(mainDir,simPathPar,'contours'))
-            simDirsLin.append(os.path.join(mainDir,simPathLin,'contours'))
-
-
-    if(drawNucleationInflowPar):
-        
-        # borders for extracting the mass growth rate
-        growthRateBorders = []
-        growthRateBorders.append([90 ,400]) #v=0.0
-        growthRateBorders.append([100,280]) #v=0.1
-        growthRateBorders.append([100,260]) #v=0.2
-        growthRateBorders.append([100,240]) #v=0.3
-        growthRateBorders.append([100,220]) #v=0.4
-        growthRateBorders.append([100,200]) #v=0.5
-
-        # create the graph with mass = f(t)
-        create_mass_graph(simDirsPar,
-                          legend=velocityLegArrayPar,
-                          width=3,
-                          xlabel='t',
-                          ylabel='mass(t)',
-                          show=True,
-                          add_zoom_above=True,
-                          add_linear_interpolation=True,
-                          borders_linear_interpolation=growthRateBorders,
-                          legendLoc='upper right',
-                          styleDashed=False)
-
-        # extract time+mass nucleation
-        get_nucleation_qties(simDirsPar)
-
-
-    if(drawNucleationInflowLin):
-
-        # borders for extracting the mass growth rate
-        growthRateBorders = []
-        growthRateBorders.append([90 ,400]) #v=0.0
-        growthRateBorders.append([100,280]) #v=0.1
-        growthRateBorders.append([110,240]) #v=0.2
-        growthRateBorders.append([110,200]) #v=0.3
-        growthRateBorders.append([140,200]) #v=0.4
-        growthRateBorders.append([255,300]) #v=0.5
-        
-        # create the graph with mass = f(t)
-        create_mass_graph(simDirsLin,
-                          legend=velocityLegArrayLin,
-                          width=3,
-                          xlabel='t',
-                          ylabel='mass(t)',
-                          show=True,
-                          add_zoom_above=True,
-                          add_linear_interpolation=True,
-                          borders_linear_interpolation=growthRateBorders,
-                          legendLoc='upper right',
-                          styleDashed=False)
-
-        # extract time+mass nucleation
-        get_nucleation_qties(simDirsLin)
-
-
-    # directories for the simulations with the linear
-    # or parabolic profiles and nucleation : varying fluxes 
-    simDirsPar = []
-    simDirsLin = []
-
-    velocity = 0.4
-
-    if(drawNucleationFluxLin or drawNucleationFluxPar):
-
-        for heatFlux in heatFluxArray:
-    
-            simDir = 'dim2d_0.95_ca'+str(contactAngle)+\
-                '_vap'+\
-                '_fh'+str(heatFlux)
-            
-            simPathPar = simDir+\
-                '_v'+str(velocity)+\
-                '_hca0.0'
-
-            simPathLin = simDir+\
-                '_vl'+str(velocity)+\
-                '_hca0.0'
-
-            simDirsPar.append(os.path.join(mainDir,simPathPar,'contours'))
-            simDirsLin.append(os.path.join(mainDir,simPathLin,'contours'))
-
-    if(drawNucleationFluxPar):
-
-        # borders for extracting the mass growth rate
-        growthRateBorders = []
-        growthRateBorders.append([100,180]) #fh=0.04
-        growthRateBorders.append([60,190])  #fh=0.05
-        growthRateBorders.append([45,160])  #fh=0.06
-        growthRateBorders.append([25,140])  #fh=0.08
-        growthRateBorders.append([20,45])   #fh=0.1
-
-        # graph with the vapor mass
-        create_mass_graph(simDirsPar,
-                          legend=heatFluxLegArray,
-                          width=3,
-                          xlabel='t',
-                          ylabel='mass(t)',
-                          show=True,
-                          add_zoom_above=True,
-                          add_linear_interpolation=True,
-                          borders_linear_interpolation=growthRateBorders,
-                          legendLoc='upper right',
-                          styleDashed=False)
-
-        # extract time+mass nucleation
-        get_nucleation_qties(simDirsPar)
-
-    if(drawNucleationFluxLin):
-
-        # borders for extracting the mass growth rate
-        growthRateBorders = []
-        growthRateBorders.append([140,200]) #fh=0.04
-        growthRateBorders.append([70,150])  #fh=0.05
-        growthRateBorders.append([45,140])  #fh=0.06
-        growthRateBorders.append([25,120])  #fh=0.08
-        growthRateBorders.append([20,70])   #fh=0.1
-
-        # graph with the vapor mass
-        create_mass_graph(simDirsLin,
-                          legend=heatFluxLegArray,
-                          width=3,
-                          xlabel='t',
-                          ylabel='mass(t)',
-                          show=True,
-                          add_zoom_above=True,
-                          add_linear_interpolation=True,
-                          borders_linear_interpolation=growthRateBorders,
-                          legendLoc='upper right',
-                          styleDashed=False)
-
-        # extract time+mass nucleation
-        get_nucleation_qties(simDirsLin)
-        
-    if(drawNucleationTimePar or drawNucleationTimeLin):
-
-        dirs = []
-        velocities = []
-        leg  = [0.04,0.05,0.06,0.08,0.1]
-        styles = ['o-','^-','s-','p-','.-',]
-
-
-        # flux = 0.04
-        dirs.append([
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.04_v0.1_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.04_v0.2_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.04_v0.3_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.04_v0.4_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.04_v0.5_hca0.0')])
-
-        velocities.append([0.1,0.2,0.3,0.4,0.5])
-
-
-        # flux = 0.05
-        dirs.append([
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.05_v0.2_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.05_v0.4_hca0.0')])
-
-        velocities.append([0.2,0.4])
-
-
-        # flux = 0.06
-        dirs.append([
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.06_v0.2_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.06_v0.4_hca0.0')])
-
-        velocities.append([0.2,0.4])
-
-
-        # flux = 0.08
-        dirs.append([
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.08_v0.2_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.08_v0.4_hca0.0')])
-
-        velocities.append([0.2,0.4])
-
-
-        # flux = 0.1
-        dirs.append([
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.1_v0.2_hca0.0'),
-                os.path.join(mainDir,'dim2d_0.95_ca22.5_vap_fh0.1_v0.4_hca0.0')])
-
-        velocities.append([0.2,0.4])
-
-
-        if(drawNucleationTimePar):
-
-            create_nucleation_time_graph(dirs,
-                                         velocities,
-                                         styles,
-                                         legend=leg)
-
-#        if(drawNucleationTimeLin):
-#
-#            for i in range(0,len(dirs)):
-#
-#                dirs.append([])
-#                styles.append([])
-#
-#                styles[len(dirs)+i].append(styles[i].replace('-','--',1))
-#
-#                for j in range(0,len(dirs[i])):
-#
-#                    dirs[len(dirs)+i].append(dirs[i][j].replace('_v0','_vl0',1))
-#
-#            print dirs
-#            print styles
-#
-##            create_nucleation_time_graph(dirs,
-##                                         velocities,
-##                                         styles,
-##                                         legend=leg)
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_stage_graphs.py b/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_stage_graphs.py
deleted file mode 100644
index 452c6b5..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_nucleation_stage_graphs.py
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description
-draw graphs characteristic for the study of early stages
-of the bubble nucleation
-
-mass   = f(t)
-volume = g(t)
-
-
-initial time when the bubble appears, at different contact angles
-initial mass when the bubble appears, at different contact angles
-mass = f(t), at different contact angles
-'''
-
-import os
-import numpy as np
-import matplotlib.pyplot as plt
-from library_contours_graph import grayscale_to_RGB
-
-
-if __name__=='__main__':
-
-
-    # path for the simulation data
-    simDir = os.path.join(os.getenv('HOME'),
-                          'projects',
-                          'dim2d_0.95_ca135.0_vap_fh0.02',
-                          'contours')
-    
-    step = 30
-    
-
-
-    # mass and volume extraction from files
-    mass = np.loadtxt(os.path.join(simDir,'mass.txt'))
-    volume = np.loadtxt(os.path.join(simDir,'volume.txt'))
-
-    
-    # plot the mass and the volume on the same graph
-    # with two different axis
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-    ax = fig.add_subplot(111)
-
-    ax.set_xlabel(r'$t$')
-    ax.set_ylabel(r'mass($t$)')
-
-    ax2 = ax.twinx()
-    ax2.set_ylabel(r'volume($t$)')
-
-    ax.plot(mass[0:step,1],
-            mass[0:step,2],
-            'o-',
-            color=grayscale_to_RGB(0.2),
-            linewidth=3)
-
-    ax2.plot(volume[0:step,1],
-             volume[0:step,2],
-             's-',
-             color=grayscale_to_RGB(0.8),
-             linewidth=3)
-
-
-    # linear interpolation of the mass as
-    # function of time
-    i1 = [11,17]
-    i2 = [16,30]
-
-    # constant initial stage
-    xi = mass[i1[0]:i1[1],1]
-
-    av = sum(mass[i1[0]:i1[1],2])/(i1[1]-i1[0])
-    av = np.ones(len(xi))*av
-    ax.plot(xi,av,'r-',linewidth=3)
-
-    # linear growth rate
-    xi = mass[i2[0]:i2[1],1]
-    A  = np.array([xi, np.ones(len(xi))])
-    yi = mass[i2[0]:i2[1],2]
-
-    pi = np.linalg.lstsq(A.T,yi)[0] #least square approximation
-    xi = mass[i2[0]-3:i2[1],1]
-    mass_line1 = pi[0]*xi + pi[1]
-    ax.plot(xi,mass_line1,'b-',linewidth=3)
-
-
-    # linear interpolation of the volume as
-    # function of time
-
-    # constant initial stage
-    xi = volume[i1[0]:i1[1],1]
-
-    av = sum(volume[i1[0]:i1[1],2])/(i1[1]-i1[0])
-    av = np.ones(len(xi))*av
-    ax2.plot(xi,av,'r-',linewidth=3)
-
-    # linear growth rate
-    xi = volume[i2[0]:i2[1],1]
-    A  = np.array([xi, np.ones(len(xi))])
-    yi = volume[i2[0]:i2[1],2]
-
-    pi = np.linalg.lstsq(A.T,yi)[0] #least square approximation
-    xi = volume[i2[0]:i2[1],1]
-    volume_line1 = pi[0]*xi + pi[1]
-    ax2.plot(xi,volume_line1,'b-',linewidth=3)
-
-    
-    ## figure with volume as function of time
-    #
-    #
-    #plt.rc('text', usetex=True)
-    #plt.rc('font', family='serif')
-    #fig = plt.figure(figsize=(8,6))
-    #ax = fig.add_subplot(111)
-    #
-    #ax.set_xlabel(r'$t$')
-    #ax.set_ylabel(r'volume($t$)')
-    #
-    #plt.plot(volume[0:step,1],
-    #         volume[0:step,2],
-    #         'r+-',
-    #         linewidth=3)
-    #
-    plt.show()
-
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_steady_state_graphs.py b/scripts_py/wall_steady_state_automatization/contours_extraction/draw_steady_state_graphs.py
deleted file mode 100644
index 5d124d7..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/draw_steady_state_graphs.py
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description
-draw graphs chcracteristic for the study of bubble nucleation:
-
-initial time when the bubble appears, at different fluxes
-initial mass when the bubble appears, at different fluxes
-mass = f(t), at different fluxes
-
-initial time when the bubble appears, at different contact angles
-initial mass when the bubble appears, at different contact angles
-mass = f(t), at different contact angles
-'''
-
-import os
-import numpy as np
-import matplotlib.pyplot as plt
-from library_contours_graph import grayscale_to_RGB
-
-
-def create_contact_lgh_graph(simDirs,
-                             legend='None',
-                             width=3,
-                             xlabel='',
-                             ylabel='',
-                             show=True,
-                             logScale=False,
-                             figPath=''):
-    '''
-    @description: create a graph with the contact length
-    as function of time for different contact angles
-    '''
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-
-
-    # plot the mass as function of time
-    # as the main plot
-    ax = fig.add_subplot(111)
-
-    for i in range(0,len(simDirs)):
-        
-        contactLgh = np.loadtxt(os.path.join(simDirs[i],'contact_lgh_n.txt'))
-
-        # plot the mass as function
-        # of time on the main graph
-        grayscale_value = 0.2+ 0.8*float(i)/float(len(simDirs))
-        
-        #timeDev = np.empty([len(contactLgh[:,0])-2,2])
-        #
-        #for j in range(1,len(contactLgh[:,0])-1):
-        #
-        #    timeDev[j-1,0] = contactLgh[j-1,1]
-        #
-        #    timeDev[j-1,1] = (contactLgh[j+1,2]-contactLgh[j-1,2])/\
-        #                     (contactLgh[j+1,1]-contactLgh[j-1,1])
-        #
-        #plt.plot(timeDev[:,0],
-        #         timeDev[:,1],
-        #         '-',
-        #         linewidth=width,
-        #         color=grayscale_to_RGB(grayscale_value))
-
-        plt.plot(contactLgh[:,1],
-                 contactLgh[:,2],
-                 '+-',
-                 linewidth=width,
-                 color=grayscale_to_RGB(grayscale_value))
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-    
-    if(logScale):
-        #ax.set_xscale('log')
-        ax.set_yscale('log')
-
-    if(legend!='None'):
-        plt.legend(legend,loc='lower right')
-
-    ax.set_xlim([0,30])
-
-    if(show):
-        plt.show()
-        plt.close()
-
-
-    if(not figPath==''):
-        plt.savefig(figPath)
-
-
-if __name__=='__main__':
-
-    mainDir = os.path.join(os.getenv('HOME'),'projects')
-
-    T=0.95
-
-
-    #=============================================================
-    # Steady state study at different contact angles
-    #=============================================================
-
-    # directories for the nucleation study with
-    # different contact angles
-    contactAngleArray = [22.5,45.0,67.5,90.0,112.5,135.0]
-
-    simDirs = []
-
-    for contactAngle in contactAngleArray:
-
-        simDir = 'dim2d_'+str(T)+'_ca'+str(contactAngle)+'_vap'
-        simDirs.append(os.path.join(mainDir,simDir,'contours'))
-
-
-    # draw a graph with the mass = f(t) for the different simulations
-    create_contact_lgh_graph(simDirs,
-                             legend=contactAngleArray,
-                             width=3,
-                             xlabel='t',
-                             ylabel='r(t)',
-                             show=True,
-                             logScale=False)
-    
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_bubble_contours.py b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_bubble_contours.py
deleted file mode 100644
index e487fed..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_bubble_contours.py
+++ /dev/null
@@ -1,608 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description
-extract the bubble contours over time and provide insight on the mass
-contained in the vapor phase...
-'''
-
-import sys
-import os
-import getopt
-
-sys.path.append(os.environ['VISIT_PYTHON_LIB'])
-import visit
-
-from library_nc_to_vtklines import (generate_vtklines,
-                                    generate_time_contour_data)
-
-from library_contact_lgh import curves_to_contact_lgh
-
-from library_volume import curves_to_volume
-
-from library_contours_graph import (create_graph,
-                                    create_st_graph,
-                                    create_sph_graph)
-
-
-import numpy as np
-import matplotlib.pyplot as plt
-from math import cos, sin, sqrt, pi
-
-
-def iround(x):
-    """iround(number) -> integer
-    Round a number to the nearest integer."""
-    return int(round(x) - .5) + (x > 0)
-
-
-def usage():
-    '''
-    @description:
-    describe the usage of the python script
-    '''
-    
-    print ''
-    print '-h : display this help'
-    print '-i : input folder where the data*.nc files are saved'
-    print '-c : contact angle for the spherical cap approximation'
-    print '-t : data files analyzed [i_min,i_max,i_step]'
-    print '-p : phase checked: needed for bubble nucleation postprocessing'
-    print '     otherwise, the contours do not match the interface between'
-    print '     the liquid and vapor phases'
-    print '-g : generate the contour files, otherwise, it is assumed that'
-    print '     the contours files have already been generated'
-    print '-s : show the graphs'
-    print '-x : set the limits for the x-axis when plotting the graphs'
-    print '-y : set the limits for the y-axis when plotting the graphs'
-    print '-w : run the visit engine without window'
-    print '-l : contourType used to determine the mass contours:'
-    print ''
-    print '        - wall_max_gradient: determine the location of the maximum'
-    print '                             gradient at the wall and use the mass'
-    print '                             density at this location'
-    print '        - max_gradient     : determine the location of the maximum'
-    print '                             gradient and use the mass density at'
-    print '                             this location'
-    print '        - mass             : use the mid-mass between the liquid'
-    print '                             and vapor satured phases at the'
-    print '                             simulation temperature'
-    print '-r : reflection activated '
-    print '-e : do not select the final time'
-    print '-a : scaling for the time steps: t**a'
-#    print '-v : re-compute the volumes'
-    print '        '
-    print ''
-    print 'ex: ./extract_bubble_contour.py -i <dir> -c <90.0> -t [0,100,10]'
-    print ''
-    print '    this will create a new directory in <dir> named contours'
-    print '    and create files where the contour coordinates are saved'
-    print '    as well as contact_length and volume files and pictures'
-    print '    of the contact line at different time steps with the'
-    print '    spherical cap approximation contour'
-
-    return
-
-
-def parse_opts(argv):
-    '''
-    @description:
-    parse the options of the script
-    '''
-
-    try:
-        opts, args = getopt.getopt(argv,
-                                   "hi:c:t:pgx:y:wsl:rea:",
-                                   ["help",
-                                    "inputDir",
-                                    "contactAngle=",
-                                    "timeFrame=",
-                                    "phaseCheck",
-                                    "genContours",
-                                    "show",
-                                    "no_window",
-                                    "reflection"])
-    except getopt.GetoptError:
-        usage()
-        sys.exit(2)
-        
-    inputDirProvided      = False
-    contactAngleProvided  = False
-    timeFrameProvided     = False
-
-    options = {}
-    options['phaseCheck']        = False
-    options['genContours']       = False
-    options['show']              = False
-    options['x_limits']          = 'None'
-    options['y_limits']          = 'None'
-    options['no_window']         = False
-    options['contourType']       = 'wall_max_gradient' #'mass', 'gradient'
-    options['reflection']        = False
-    options['select_end_time']   = True
-    options['scaling_timesteps'] = 'None'
-
-
-    for opt, arg in opts:
-
-        if opt in ("-h","--help"):
-            usage()
-            sys.exit(2)
-            
-        elif opt in ("-i", "--inputDir"):
-            if(os.path.isdir(arg)):
-                inputDirProvided = True
-                options['inputDir'] = arg
-            else:
-                print '*** '+arg+' does not exist ***'
-            
-        elif opt in ("-c", "--contactAngle"):
-            try:
-                contactAngle = float(arg)
-                contactAngleProvided = True
-
-                options['contactAngle'] = contactAngle
-
-            except ValueError:
-                contactAngleProvided = False
-                print '*** '+arg+' is not a valid contact angle ***'
-            
-        elif opt in ("-t", "--timeFrame"):
-            try:
-                timeFrame = arg.split('[')[1].split(']')[0].split(',')
-                for i in range(0,len(timeFrame)):
-                    timeFrame[i] = int(timeFrame[i])
-                timeFrameProvided = True
-
-                options['timeFrame'] = timeFrame
-
-            except ValueError:
-                timeFrameProvided = False
-                print '*** '+arg+' is not a valid list time frame [i_min,i_max,i_step] ***'
-
-        elif opt in ("-p","--phaseCheck"):
-            options['phaseCheck'] = True
-
-        elif opt in ("-g","--genContours"):
-            options['genContours'] = True
-
-        elif opt in ("-s","--show"):
-            options['show'] = True
-
-        elif opt in ("-x"):
-            try:
-                x_limits = arg.split('[')[1].split(']')[0].split(',')
-                for i in range(0,len(x_limits)):
-                    x_limits[i] = float(x_limits[i])
-
-                options['x_limits'] = x_limits
-
-            except ValueError:
-                print '*** '+arg+' is not a valid list x-limits [x_min,x_max] ***'
-
-        elif opt in ("-y"):
-            try:
-                y_limits = arg.split('[')[1].split(']')[0].split(',')
-                for i in range(0,len(y_limits)):
-                    y_limits[i] = float(y_limits[i])
-
-                options['y_limits'] = y_limits
-
-            except ValueError:
-                print '*** '+arg+' is not a valid list x-limits [x_min,x_max] ***'
-
-        elif opt in ("-w","--no_window"):
-            options['no_window'] = True
-
-        elif opt in ("-l"):
-            
-            if arg in ['wall_max_gradient','max_gradient','mass']:
-                options["contourType"] = arg
-
-            else:
-                print 'contourType not recognized'
-                usage()
-                sys.exit(2)
-
-        elif opt in ("-r"):
-
-            options['reflection'] = True
-
-        elif opt in ("-e"):
-            
-            options['select_end_time'] = False
-
-        elif opt in ("-a"):
-
-            options['scaling_timesteps'] = int(arg)
-
-
-    if(not(inputDirProvided and contactAngleProvided and timeFrameProvided)):
-        print 'the options are not correctly provided'
-        usage()
-        sys.exit(2)
-
-    print 'input_dir     : ', options['inputDir']
-    print 'contact_angle : ', options['contactAngle']
-    print 'time_frame    : ', options['timeFrame']
-    print 'phase_check   : ', options['phaseCheck']
-    print 'gen_contours  : ', options['genContours']
-    print 'show          : ', options['show']
-    print 'x_limits      : ', options['x_limits']
-    print 'y_limits      : ', options['y_limits']
-    print 'no_window     : ', options['no_window']
-    print ''
-    
-    return options
-
-
-def generate_st_graphs(ncFolder,
-                       timeRange,
-                       contactAngle,
-                       contourType,
-                       phase_check=False,
-                       contourPer=0.1,
-                       genContours=False,
-                       maxNbBubbleContours='None',
-                       show=True,
-                       x_limits='None',
-                       y_limits='None',
-                       reflection=False,
-                       select_end_time=True,
-                       scalingTimesteps='None'):
-    '''
-    @description: generate the contours of the bubble
-    at different timesteps, extract the contact length
-    of the bubble at the wall, the volume of the bubble
-    in time and plot the contours at different timesteps
-    as well as the spherical cap approximation    
-    '''
-
-    # determine the paths to the folders
-    ncRootPath  = os.path.join(ncFolder,'data')
-    contoursDir = os.path.join(ncFolder,'contours')
-    contoursRootPath = os.path.join(contoursDir,'contours')
-
-    
-    # choose whether to create the graph with the spherical cap
-    # approximation
-    add_spherical_cap_approx = not phase_check
-
-    
-    # if there is no existing contour folder
-    # create one    
-    if(not os.path.isdir(contoursDir)):
-        os.makedirs(contoursDir)
-
-
-    ## extract the contact length and the volume
-    ## as functions of time
-    if(genContours):
-        generate_time_contour_data(
-            ncRootPath,
-            contoursRootPath,
-            timeRange=timeRange,
-            var='mass',
-            contourPer=contourPer,
-            contourType=contourType,
-            phase_check=phase_check,
-            reflection=reflection)
-    
-
-    # paths for saving the contact angle and volume figures
-    contact_lgh_path = os.path.join(contoursDir,'contact_lgh.txt')
-    volume_path      = os.path.join(contoursDir,'volume.txt')
-    mass_path        = os.path.join(contoursDir,'mass.txt')
-    contour_path     = os.path.join(contoursDir,'contour.txt')
-    temperature_path = os.path.join(contoursDir,'temperature.txt')
-    dataRootPath     = contoursDir
-
-    contactLghFigPath  = os.path.join(contoursDir,'contact_lgh.eps')
-    volumeFigPath      = os.path.join(contoursDir,'volume.eps')
-    massFigPath        = os.path.join(contoursDir,'mass.eps')
-    contourFigPath     = os.path.join(contoursDir,'mass_contour.eps')
-    temperatureFigPath = os.path.join(contoursDir,'temperature.eps')
-    contoursFigPath    = os.path.join(contoursDir,'contours.eps')
-    contoursStFigPath  = os.path.join(contoursDir,'contours_st.eps')
-
-
-    # plot the contact length as funtion of time
-    curves_to_contact_lgh(ncFolder)
-    curves_to_volume(ncFolder)
-
-    create_graph(contact_lgh_path,
-                 contactAngle=contactAngle,
-                 xlabel='$t$',
-                 ylabel='contact length',
-                 figPath=contactLghFigPath,
-                 width=3,
-                 logScale=False,
-                 show=show,
-                 plotLengthEq=add_spherical_cap_approx,
-                 volumePath=volume_path)
-    
-    # plot the volume as function of time
-    create_graph(volume_path,
-                 xlabel='$t$',
-                 ylabel='volume',
-                 figPath=volumeFigPath,
-                 width=3,
-                 logScale=False,
-                 show=False)
-
-    # plot the mass as function of time
-    create_graph(mass_path,
-                 xlabel='$t$',
-                 ylabel='mass',
-                 figPath=massFigPath,
-                 width=3,
-                 logScale=False,
-                 show=False)
-
-    # plot the mass chosen to draw the
-    # contours as function of time
-    create_graph(contour_path,
-                 xlabel='$t$',
-                 ylabel='mass',
-                 figPath=contourFigPath,
-                 width=3,
-                 logScale=False,
-                 show=show)
-
-    # plot the temperature chosen to draw the
-    # contours as function of time
-    create_graph(temperature_path,
-                 xlabel='$t$',
-                 ylabel='$T$',
-                 figPath=temperatureFigPath,
-                 width=3,
-                 logScale=False,
-                 show=show)
-
-
-    # plot the contour at different time steps:
-    # choose the timesteps to have only maxNbBubbleContours
-    #------------------------------------------------------------
-
-    # get the first timestep with a bubble
-    volumePath = dataRootPath+'/volume.txt'
-    volume = np.loadtxt(volumePath)
-    for i in range(0,len(volume[:,0])):
-        if(volume[i,2]>0):
-            start_i = i
-            break
-    start_i = max(start_i,timeRange[0])
-
-    end_i = len(volume[:,0])-1
-    if(select_end_time):
-        for i in range(len(volume[:,0])-1,start_i,-1):
-            if(volume[i,2]>0):
-                end_i = i
-                break
-    end_i = min(end_i,timeRange[1])
-    nt = len(volume[:,0])
-
-
-    # select the timesteps
-    if(maxNbBubbleContours=='None'):
-        nbContours = end_i-start_i+1
-    else:
-        nbContours = maxNbBubbleContours
-
-    if(scalingTimesteps=='None'):
-        scaling=1.0
-    else:
-        scaling=scalingTimesteps
-
-
-    # extraction of the timesteps to
-    # display the contours
-    times   = []
-    times_t = []
-
-    #times.append(start_i)
-    #times_t.append(volume[start_i,1])
-
-    for i in range(0,nbContours):
-
-        step = float(end_i-start_i)*(float(i)/float(nbContours-1))**scaling
-        if(step>0):
-            step = max(1,iround(step))
-        else:
-            step = 0
-
-        timestep = start_i + step
-
-        times.append(timestep)
-        times_t.append(volume[timestep,1])
-
-    #times.append(end_i)
-    #times_t.append(volume[end_i,1])
-
-#    times = []
-#    if(maxNbBubbleContours=='None'):
-#        step = 1
-#    else:
-#        step = int(float(end_i-start_i)/float(maxNbBubbleContours))
-#    step = max(1,step)
-#
-#    for i in range(start_i,end_i,step):
-#        times.append(int(volume[i,0]))
-#    times.append(int(volume[end_i,0]))
-#    #times[-2] = 304 #for 0.95_ca135.0_vl0.4_sph to see the bubble expulsed
-#
-#    times_t = []
-#    for i in range(start_i,end_i,step):
-#        times_t.append(volume[i,1])
-#    times_t.append(volume[end_i,1])
-
-    times_p = np.array(times_t)
-    np.set_printoptions(precision=5)
-    print 'Timesteps for contours: '
-    print times
-    print 'Time extracted for contours: '
-    print times_p
-
-    # create the graph with only the contours at different
-    # relevant times
-    create_st_graph(dataRootPath,
-                    times,
-                    contactAngle,
-                    xlabel='$x$',
-                    ylabel='',
-                    figPath=contoursFigPath,
-                    width=3,
-                    show=show,
-                    x_limits=x_limits,
-                    y_limits=y_limits)
-
-    # create the graph with only the last contours and the
-    # spherical cap approximation
-    if(add_spherical_cap_approx):
-        create_sph_graph(dataRootPath,
-                         times[-1],
-                         contactAngle,
-                         figPath=contoursStFigPath,
-                         show=show,
-                         x_limits=x_limits,
-                         y_limits=y_limits)
-
-
-def find_initial_bubble(volumePath):
-    '''
-    @description: find the time at which the bubble appears
-    and the initial volume of the bubble
-    '''
-    
-    volume = np.loadtxt(volumePath)
-    
-    for (t,v) in zip(volume[:,1],volume[:,2]):
-        if(v>0):
-            t_i = t
-            v_i = v
-            break
-    
-    return [t_i,v_i]
-
-
-def compute_contact_length_variation(contactLghPath,
-                                     volumePath,
-                                     contact_angle):
-    '''
-    @description: find the normalized difference between the
-    contact length and the equilibrium contact length computed
-    from the volume and the contact angle as function of time
-    '''
-
-    print 'contact_angle: ', contact_angle
-
-    theta  = pi*float(180-contact_angle)/180.0
-    theta1 = pi-theta
-        
-    contactLgh = np.loadtxt(contactLghPath)
-    volume     = np.loadtxt(volumePath)
-
-    nt = len(contactLgh[:,0])
-
-    contactLghDiff = np.empty([nt])
-
-    for i in range(0,nt):
-
-        volumet = volume[i,2]
-
-        eq_R   = sqrt(volumet)*1.0/sqrt(pi-theta1+cos(theta1)*sin(theta1))
-        eq_lgh = 2.0*eq_R*sin(theta1)
-
-        contactLghEq = eq_lgh #2.0*sqrt(volumet/((pi-theta)+cos(theta)*sin(theta)))*sin(theta)
-
-        contactLghDiff[i] = (contactLghEq-contactLgh[i,2])/contactLghEq
-
-        #print 'eq_lgh: ', contactLghEq, contactLgh[i,2], contactLghDiff[i]
-
-    out = open(os.path.join(os.path.dirname(volumePath),'contact_lgh_n.txt'), 'w')
-    for (i,t,l) in zip(volume[:,0],volume[:,1],contactLghDiff):
-        out.write("%f %f %f\n" % (i,t,l))
-    out.close()
-
-
-def generate_contact_length_variation(contoursDir,
-                                      contact_angle,
-                                      show=False):
-    '''
-    @description: compute the normalized difference of
-    the contact length as function of time and create
-    a graph
-    '''
-
-    contactLghPath = os.path.join(contoursDir,'contact_lgh.txt')
-    volumePath     = os.path.join(contoursDir,'volume.txt')
-
-    compute_contact_length_variation(contactLghPath,
-                                     volumePath,
-                                     contact_angle)
-
-    contoursNPath    = os.path.join(contoursDir,'contact_lgh_n.txt')
-    contoursNFigPath = os.path.join(contoursDir,'contact_lgh_n.eps')
-
-    # extract the contact length:
-    contactLgh = np.loadtxt(contoursNPath)
-    print 'contact_lgh: ', contactLgh[-1]
-
-    create_graph(contoursNPath,
-                 xlabel='$t$',
-                 ylabel='contact length difference',
-                 figPath=contoursNFigPath,
-                 width=3,
-                 logScale=False,
-                 show=show)
-
-
-if __name__=='__main__':
-
-    #visit.ExportDBAttributes()
-    #SuppressMessages(2)
-    #print help(visit)
-    #GetGlobalAttributes()
-
-    options = parse_opts(sys.argv[1:])
-    
-    if(options['genContours']):
-        if(options['no_window']):
-            visit.LaunchNowin()
-        else:
-            visit.Launch()
-        visit.SuppressMessages(1)
-
-    contoursPath = os.path.join(options['inputDir'],'contours')
-
-
-    ## generate the contact lengthm, the volume and
-    ## the bubble contours graphs
-    generate_st_graphs(options['inputDir'],
-                       options['timeFrame'],
-                       options['contactAngle'],
-                       options['contourType'],
-                       phase_check=options['phaseCheck'],
-                       genContours=options['genContours'],
-                       contourPer=0.1,
-                       maxNbBubbleContours=7,
-                       show=options['show'],
-                       x_limits=options['x_limits'],
-                       y_limits=options['y_limits'],
-                       reflection=options['reflection'],
-                       select_end_time=options['select_end_time'],
-                       scalingTimesteps=options['scaling_timesteps'])
-
-    [t_i,r_i] = find_initial_bubble(os.path.join(contoursPath,'volume.txt'))
-
-    print 'time bubble   : ', t_i
-    print 'initial_volume: ', r_i
-
-    options['contactLghVar'] = not options['phaseCheck']
-
-    if(options['contactLghVar']):
-
-        generate_contact_length_variation(
-            contoursPath,
-            options['contactAngle'],
-            show=options['show'])
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours2.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours2.sh
deleted file mode 100644
index 6d85ef5..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours2.sh
+++ /dev/null
@@ -1,41 +0,0 @@
-#!/bin/sh
-
-get_inflow_sph_dir(){
-    projectDir=/home/jdesmarais/projects
-    dir="$projectDir/dim2d_"$1"_ca"$2"_vap_v"$3"_hca"$4"_sph"
-    echo "$dir"
-}
-
-generate_inflow_sph_contours(){
-    pythonDir=/home/jdesmarais/Code/augeanstables/scripts_py
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    T=$1
-    ca=$2
-    v=$3
-    hca=$4
-
-    inputDir=$( get_inflow_sph_dir $T $ca $v $hca)
-
-    
-    #options="-i $inputDir -c $ca -t $5 -x $6 -y $7 -p -l max_gradient -g -w"
-    options="-i $inputDir -c $ca -t $5 -x $6 -y $7 -p -l max_gradient -s"
-
-    ./extract_bubble_contours.py  $options #>cur_contours.out 2>&1
-
-
-    echo "=================================================="
-    echo "generate_contours( "$T" , "$ca" , "$v", "$hca" ) : done"
-    echo "=================================================="
-    echo ''
-}
-
-
-T=0.95
-v=0.1
-ca=135.0
-hca=0.0
-
-generate_inflow_sph_contours $T $ca $v $hca [0,500,2] [-0.15,0.375] [0,0.25]
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_inflow_nucleation.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_inflow_nucleation.sh
deleted file mode 100644
index 877ed46..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_inflow_nucleation.sh
+++ /dev/null
@@ -1,26 +0,0 @@
-#!/bin/bash
-
-source $augeanstables/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
-
-
-#============================================================
-# extraction of the contours for the nucleation simulations
-#============================================================
-
-## flow inflow study at constant contact angle and heat flux
-T=0.95
-ca=22.5
-sh=-0.04
-hca=0.0
-
-for sh in -0.04 #-0.05 -0.06 -0.08 -0.1
-do
-    for ca in 22.5
-    do
-	for v in 0.5 #0.1 0.2 0.3 0.4 0.5
-	do
-	    options="$T $ca $sh $v $hca [0,500,1] [-0.1,0.225] [0,0.125]"
-	    generate_inflow_nucleation_contours $options
-	done
-    done
-done
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_inflow_sph.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_inflow_sph.sh
deleted file mode 100644
index a842db1..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_inflow_sph.sh
+++ /dev/null
@@ -1,29 +0,0 @@
-#!/bin/bash
-
-source $augeanstables/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
-
-
-#============================================================
-# extraction of the contours for the nucleation simulations
-#============================================================
-T=0.95
-v=0.2
-hca=0.0
-
-# contact angle study at constant velocity
-for v in 0.1 0.2 0.3 0.4 0.5
-do
-    for ca in 22.5 45.0 67.5 #90.0 112.5 135.0
-    do
-	generate_inflow_sph_contours $T $ca $v $hca [0,500,2] [-0.15,0.80] [0,0.25]
-    done
-done
-
-
-#for v in 0.1 0.2 0.3 0.4 #0.1 0.2 0.3 0.4 0.5
-#do
-#    for ca in 90.0 112.5 135.0 #135.0 #90.0 112.5 135.0
-#    do
-#	generate_inflow_sph_contours $T $ca $v $hca [0,500,2] [-0.15,0.80] [0,0.25]
-#    done
-#done
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_linear_inflow_nucleation.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_linear_inflow_nucleation.sh
deleted file mode 100644
index 88566b5..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_linear_inflow_nucleation.sh
+++ /dev/null
@@ -1,45 +0,0 @@
-#!/bin/bash
-
-source $augeanstables/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
-
-
-#============================================================
-# extraction of the contours for the nucleation simulations
-#============================================================
-
-## flow inflow study at constant contact angle and heat flux
-T=0.95
-#ca=22.5
-#fh=0.04
-hca=0.0
-
-
-steps=[0,550,1]
-xlimits=[-0.1,0.425]
-ylimits=[0,0.125]
-
-for fh in 0.04
-do
-    for ca in 22.5
-    do
-	for v in 0.0 #0.5 #0.1 0.2 0.3 0.4 0.5
-	do
-	    options="$T $ca $fh $v $hca $steps $xlimits $ylimits"
-	    generate_linear_inflow_nucleation_contours $options
-	    #generate_inflow_nucleation_contours $options
-	done
-    done
-done
-
-#for fh in 0.05 0.06 0.08 0.1
-#do
-#    for ca in 22.5
-#    do
-#	for v in 0.2 0.4
-#	do
-#	    options="$T $ca $fh $v $hca $steps $xlimits $ylimits"
-#	    generate_linear_inflow_nucleation_contours $options
-#	    #generate_inflow_nucleation_contours $options
-#	done
-#    done
-#done
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_linear_inflow_sph.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_linear_inflow_sph.sh
deleted file mode 100644
index a5f100e..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_linear_inflow_sph.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/bash
-
-source $augeanstables/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
-
-
-#============================================================
-# extraction of the contours for the nucleation simulations
-#============================================================
-T=0.95
-v=0.2
-hca=0.0
-
-# contact angle study at constant velocity
-for v in 0.5
-do
-    for ca in 90.0
-    do
-	generate_linear_inflow_sph_contours $T $ca $v $hca [0,502,2] [-0.15,0.80] [0,0.25]
-    done
-done
\ No newline at end of file
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_nucleation.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_nucleation.sh
deleted file mode 100644
index 5c48536..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_nucleation.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/bash
-
-source $augeanstables/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
-
-
-#============================================================
-# extraction of the contours for the nucleation simulations
-#============================================================
-T=0.95
-
-## heat flux study at constant contact angle
-#ca=90.0
-#for fh in 0.04 0.06 0.08 0.1
-#do
-#    generate_nucleation_contours $T $ca $fh [0,215,1] [-0.15,0.15] [0,0.125]
-#done
-
-# contact angle study at constant heat flux
-fh=0.02
-data=[0,215,1]
-data=[0,170,1]
-xlimits=[-0.15,0.15]
-ylimits=[0,0.125]
-
-for ca in 135.0 #22.5 45.0 67.5 90.0 112.5 135.0 #67.5 90.0 112.5 ##
-do
-    generate_nucleation_contours $T $ca $fh $data $xlimits $ylimits
-done
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_steady_state.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_steady_state.sh
deleted file mode 100644
index 1e1e1da..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/extract_contours_steady_state.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/bin/bash
-
-source $augeanstables/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
-
-
-#============================================================
-# extraction of the contours for the steady state simulations
-#============================================================
-T=0.95
-
-# 22.5 45.0 67.5 90.0
-for ca in 22.5 45.0 67.5 90.0 112.5 135.0
-do
-    generate_st_contours $T $ca [0,125,1] [-0.15,0.15] [0,0.15] 3
-done
-
-## 112.5 135.0
-#for ca in 112.5 135.0
-#do
-#    generate_st_contours $T $ca [0,5300,50] [-0.4,0.4] [0,0.3]
-#done
-
-## 22.5 45.0 67.5 90.0
-#ca=135.0
-#generate_st_contours $T $ca [0,5300,50] [-0.4,0.4] [0,0.3]
\ No newline at end of file
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_contact_lgh.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_contact_lgh.py
deleted file mode 100644
index 314cb15..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_contact_lgh.py
+++ /dev/null
@@ -1,130 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description:
-extract the contact length from the contours
-'''
-
-import os
-import numpy as np
-
-
-def find_transition_indices(x_data,y_data,y_lim):
-    '''
-    @description:
-    find the indices where the y_data cross the y-lim
-    '''
-
-    transition_i = []
-
-    i_prev = -99
-    for i in range(0,len(y_data)-1):
-        
-        if( ((y_data[i]-y_lim)*(y_data[i+1]-y_lim)) <= 0.0 ):
-
-            if(i!=i_prev+1 and i!=i_prev+2):
-                transition_i.append(i)
-                i_prev = i
-
-    return transition_i
-
-
-def interpolate_x_lim(x_data,y_data,y_lim):
-    '''
-    @description:
-    it is possible to linearly interpolate
-    x_lim such that y_lim = f(x_lim).
-    The linear interpolation is done using
-    (x[i],y[i]) and (x[i+1],y[i+1])
-    x_data[0:1] : x[i] and x[i+1]
-    y_data[0:1] : y[i] and y[i+1]
-    '''
-
-    x_lim = x_data[0] + (y_lim - y_data[0])/(y_data[1] - y_data[0])*(x_data[1] - x_data[0])
-    
-    return x_lim
-
-
-def compute_contact_lgh(x_data,y_data,y_lim):
-    '''
-    @description:
-    find the x-coordinates corresponding to the intersections
-    between the contour and the wall and deduce the contact
-    length
-    '''
-
-    # find the i corresponding to the data
-    #  next to the interaction with the wall
-    i_transition = find_transition_indices(x_data,y_data,y_lim)
-    
-    # interpolate the intersections with the wall
-    if(len(i_transition)==0):
-        contact_lgh = 0.0
-
-    elif(len(i_transition)%2==0):
-
-        contact_lgh = 0
-
-        for i in range(0,len(i_transition)/2):
-            i1 = i_transition[0+2*i]
-            x1 = interpolate_x_lim(x_data[i1:i1+2],y_data[i1:i1+2],y_lim)
-        
-            i2 = i_transition[1+2*i]
-            x2 = interpolate_x_lim(x_data[i2:i2+2],y_data[i2:i2+2],y_lim)
-
-            contact_lgh+= abs(x2-x1)
-
-    else:
-        print 'problem when extracting the contact lgh: ', i_transition
-        contact_lgh = -1
-
-    return contact_lgh
-
-
-def curves_to_contact_lgh(dirPath,yWall=0.0):
-    '''
-    @description:
-    find the contact length from the contours
-    '''
-    
-    contourRootPath = os.path.join(dirPath,'contours')
-
-    volumePath = os.path.join(contourRootPath,'volume.txt')
-    volumeData = np.loadtxt(volumePath)
-
-    nt = len(volumeData[:,0])
-
-    contactLghData = np.empty([nt])
-
-    
-    # compute the contact length for all the timesteps
-    for i in range(0,nt):
-
-        i_t = volumeData[i,0]
-        t   = volumeData[i,1]
-        
-        contourFile = 'contours'+str(int(i_t))+'.curve'
-
-        curvePath = os.path.join(contourRootPath,contourFile)
-
-        if(os.path.isfile(curvePath)):
-            curveData = np.loadtxt(curvePath)
-            contactLghData[i] = compute_contact_lgh(curveData[:,0],
-                                                    curveData[:,1],
-                                                    yWall)
-        else:
-            contactLghData[i] = 0.0
-
-
-    # write the length(t) in an output file
-    out = open(os.path.join(contourRootPath,'volume2.txt'), 'w')
-    for (i,t,l) in zip(volumeData[:,0],volumeData[:,1],contactLghData):
-        out.write("%f %f %f\n" % (i,t,l))
-    out.close()
-
-
-if __name__=='__main__':
-    
-    dirPath = os.path.join('/home/jdesmarais/projects','dim2d_0.95_ca22.5_vap')
-
-    curves_to_contact_lgh(dirPath)
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_contours_detachment.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_contours_detachment.py
deleted file mode 100644
index dcf67e3..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_contours_detachment.py
+++ /dev/null
@@ -1,98 +0,0 @@
-#!/usr/bin/python
-
-
-import numpy as np
-from math import sqrt
-
-def find_detachment_time(contactLghPath):
-    '''
-    @description: find the time at which the 
-    contact length becomes zero in the table of
-    contact length as function of time
-    '''
-
-    # the file contains the data organized as :
-    # fileIndex, time, contact-length
-    #
-    # the fileIndex allows to associate a 
-    # mass contour and the corresponding netcdf
-    # file to a specific time
-    #
-    # e.g. data40.nc <-> contours40.txt
-    # 
-    contactLgh = np.loadtxt(contactLghPath)
-
-    print contactLghPath
-
-    i_detachment = 0
-    t_detachment = 0.
-    detachment   = False
-
-    for i in range(0,len(contactLgh[:,0])):
-
-        if(contactLgh[i,2]==0.0):
-            i_detachment = int(contactLgh[i,0])
-            t_detachment = contactLgh[i,1]
-            detachment = True
-
-            if(contactLgh[i,1]==0.0):
-                detachment = False
-            break
-
-    
-
-    return (detachment, i_detachment,t_detachment)
-
-
-def find_bubble_extent(contourData):
-    '''
-    @description: find the couple of points
-    in the polyline describing the bubble mass
-    contour that will lead to the longest segment
-    i.e. what is the length of the largest segment
-    that can fit inside the bubble
-    '''
-
-    # the data in contourData are organized
-    # as:
-    # - x : contourData[0,:]
-    # - y : contourData[1,:]
-
-    max_length = 0.0
-
-    # the coordinates of the segment points
-    # are organized as follow:
-    # 1st point: (x,y) = ([0,0],[0,1])
-    # 2nd point: (x,y) = ([1,0],[1,1])
-    segment_pts = np.empty([2,2])
-
-    # loop over the points in the polyline
-    npts = len(contourData[:,0])
-    for i in range(0,npts):
-
-        x1 = contourData[i,0]
-        y1 = contourData[i,1]
-
-        # create a couple with another point in the polyline
-        for j in range(i+1,npts):
-
-            x2 = contourData[j,0]
-            y2 = contourData[j,1]
-
-            # compute the distance between the two points
-            distance = (x2-x1)**2 + (y2-y1)**2
-
-            # if the distance is larger than the maximum
-            # distance save the coordinates of the segment
-            # points
-            if(distance > max_length):
-
-                segment_pts[0,0] = x1
-                segment_pts[1,0] = x2
-
-                segment_pts[0,1] = y1
-                segment_pts[1,1] = y2
-
-                max_length = distance
-
-    return (sqrt(max_length),segment_pts)
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_contours_graph.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_contours_graph.py
deleted file mode 100644
index 06e0e03..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_contours_graph.py
+++ /dev/null
@@ -1,410 +0,0 @@
-#!/usr/bin/python
-
-from math import sqrt,pi,sin,cos,acos
-import numpy as np
-import matplotlib.pyplot as plt
-import os
-import sys
-
-
-def extract_domain_borders(dataPath):
-    '''
-    @description: extract the domain borders from
-    the input file
-    '''
-
-    data = np.loadtxt(dataPath)
-
-    domain_borders = {}
-    domain_borders['x_min'] = data[0]
-    domain_borders['x_max'] = data[1]
-    domain_borders['y_min'] = data[2]
-    domain_borders['y_max'] = data[3]
-    domain_borders['dx']    = data[4]
-    domain_borders['dy']    = data[5]
-
-    return domain_borders
-
-
-def get_equilibrium_length(Ri,theta):
-    '''
-    @description: compute the equilibirum length corresponding
-    to the contact angle and the initial radius
-    '''
-
-    eq_lgh = Ri*sqrt(pi/2.0)*sin(theta)/sqrt(theta-0.5*sin(2*theta))
-
-    return eq_lgh
-
-
-def get_spherical_cap_data(y_min,xmin,xmax,Ri,theta,filled=False):
-    '''
-    @description: compute the spherical cap shape corresponding
-    to an equilibrium contact angle between vapor and liquid equal
-    to theta
-    '''
-    
-    if(filled):
-        theta1 = pi-theta
-        eq_R   = Ri*sqrt(pi/2.0)*1.0/sqrt(pi-theta1+cos(theta1)*sin(theta1))
-        eq_lgh = eq_R*sin(theta1)
-
-        x1 = [xmin,-eq_lgh]
-        y1 = [y_min,y_min]
-
-        x2 = np.arange(-eq_lgh,-eq_R,(-eq_R+eq_lgh)/300.)
-        y2 = np.empty([len(x2)])
-        
-        for i in range(0,len(x2)):
-            y2[i] = y_min+eq_R*cos(theta1)-eq_R*sin(acos(x2[i]/eq_R))
-
-        x3 = np.arange(-eq_R,eq_R,2*eq_R/1000.)
-        y3 = np.empty([len(x3)])
-        
-        for i in range(0,len(x3)):
-            y3[i] = y_min+eq_R*cos(theta1)+eq_R*sin(acos(x3[i]/eq_R))
-
-        x4 = np.arange(eq_R,eq_lgh,(-eq_R+eq_lgh)/300.)
-        y4 = np.empty([len(x4)])
-        
-        for i in range(0,len(x4)):
-            y4[i] = y_min+eq_R*cos(theta1)-eq_R*sin(acos(x4[i]/eq_R))
-
-        x5 = [eq_lgh,xmax]
-        y5 = [y_min,y_min]
-
-        x1_i = len(x1)
-        x2_i = x1_i+len(x2)
-        x3_i = x2_i+len(x3)
-        x4_i = x3_i+len(x4)
-        x5_i = x4_i+len(x5)
-
-        x = np.empty([x5_i])
-        y = np.empty([len(x)])
-
-        x[   0:x1_i] = x1
-        y[   0:x1_i] = y1
-        x[x1_i:x2_i] = x2
-        y[x1_i:x2_i] = y2
-        x[x2_i:x3_i] = x3
-        y[x2_i:x3_i] = y3
-        x[x3_i:x4_i] = x4
-        y[x3_i:x4_i] = y4
-        x[x4_i:x5_i] = x5
-        y[x4_i:x5_i] = y5
-
-    else:
-        eq_lgh = get_equilibrium_length(Ri,theta)
-        eq_R   = Ri*sqrt(pi/2.0)*1.0/sqrt(theta-cos(theta)*sin(theta))
-
-        x = np.arange(xmin,xmax,(xmax-xmin)/1000.)
-        y = np.empty([len(x)])
-        
-        for i in range(0,len(x)):
-            
-            if(x[i]<-eq_lgh or x[i]>eq_lgh):
-                y[i] = y_min
-            else:
-                y[i] = y_min + eq_R*( sin(acos(x[i]/eq_R)) - cos(theta) )
-                
-    return [x,y]
-
-
-def grayscale_to_RGB(grayscale_value):
-    '''
-    @description
-    determine the RGB code for a color from
-    its grayscale values
-    '''
-    
-    if( (0<=grayscale_value) and (grayscale_value<=1) ):
-
-        R = 1.0 - grayscale_value
-
-    else:
-
-        print 'error for grayscale value'
-        print grayscale_value
-        sys.exit(2)            
-
-    return (R,R,R)
-
-
-def create_graph(data_path,
-                 xlabel='$t$',
-                 ylabel='',
-                 figPath='',
-                 width=3,
-                 logScale=False,
-                 show=True,
-                 contactAngle='None',
-                 plotLengthEq=False,
-                 volumePath='None'):
-    '''
-    @description: print a graph of the contact length
-    as function of time
-    '''
-
-    data = np.loadtxt(data_path)
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(8,6))
-
-    ax = fig.add_subplot(111)
-    
-    plt.plot(
-        data[:,1],
-        data[:,2],
-        '-',
-        linewidth=width,
-        color='black')
-
-    if(contactAngle!='None' and plotLengthEq and volumePath!='None'):
-        volume = np.loadtxt(volumePath)
-        Ri = sqrt(2.0*volume[-1,2]/pi)
-        theta = (180-contactAngle)*pi/180
-
-        data[:,2] = 2.0*get_equilibrium_length(Ri,theta)
-
-        plt.plot(
-            data[:,1],
-            data[:,2],
-            '--',
-            linewidth=width,
-            color='red')
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ ylabel)
-
-    if(logScale):
-        ax.set_xscale('log')
-        ax.set_yscale('log')
-    
-    if(show):
-        plt.show()
-        plt.close()
-
-    if(not figPath==''):
-        plt.savefig(figPath)
-
-
-def create_st_graph(dataRootPath,
-                    timestepExtracted,
-                    contactAngle,
-                    xlabel='$t$',
-                    ylabel='',
-                    figPath='',
-                    width=3,
-                    show=True,
-                    x_limits='None',
-                    y_limits='None'):
-    '''
-    description: create a graph with the bubble contours
-    at several timesteps
-    '''
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(12,6))
-
-    ax = fig.add_subplot(111,aspect='equal')
-
-    y_min = 0.0
-    y_max = 0.0
-
-    # plot the bubble shape at different times
-    for i in range(0,len(timestepExtracted)):
-    
-        timestep = timestepExtracted[i]
-
-        dataPath = os.path.join(dataRootPath,'contours'+str(timestep)+'.curve')
-
-        if(os.path.isfile(dataPath)):
-
-            data = np.loadtxt(dataPath)
-        
-            if(timestep==timestepExtracted[-1]):
-                ratio = 1
-            else:
-                ratio = float(i)/float(len(timestepExtracted)-1)
-                # ratio = (float(timestep)-float(timestepExtracted[0]))/\
-                #         (float(timestepExtracted[-1])-float(timestepExtracted[0]))
-
-            if(not (0<=ratio<=1)):
-                print 'timestep    ', timestep
-                print 'timestep[0] ', timestepExtracted[0]
-                print 'timestep[-1]', timestepExtracted[-1]
-
-            grayscale_value = 0.1 + 0.9*ratio
-        
-            # plot the first bubble shape with dashed line
-            if(i==0):
-                plotstyle = '--'
-                linewidth = 2
-                color = 'black'
-            
-            # plot the last bubble with dashed line
-            elif(i==len(timestepExtracted)-1):
-                plotstyle = '--'
-                linewidth = 2
-                color = 'black'
-
-            # plot the other bubbles with continuous line
-            else:
-                plotstyle = '-'
-                linewidth = width
-                color = grayscale_to_RGB(grayscale_value)
-            
-            plt.plot(
-                data[:,0],
-                data[:,1],
-                plotstyle,
-                linewidth=linewidth,
-                color=color)
-    
-            y_min = min(y_min,min(data[:,1]))
-            y_max = max(y_max,max(data[:,1]))
-
-    y_max = 1.05*y_max
-
-    plt.ylim([y_min,y_max])
-
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-
-    # set the limits
-    if(x_limits!='None'):
-        plt.xlim(x_limits)
-
-    if(y_limits!='None'):
-        plt.ylim(y_limits)
-
-            
-    # show the graph
-    if(show):
-        plt.show()
-        plt.close()
-
-                
-    # save in .eps format
-    if(not figPath==''):
-        plt.savefig(figPath)
-
-
-def create_sph_graph(dataRootPath,
-                     timestep,
-                     contactAngle,
-                     xlabel='$x$',
-                     ylabel='',
-                     figPath='',
-                     width=3,
-                     show=True,
-                     x_limits='None',
-                     y_limits='None'):
-    '''
-    description: create a contour for the last time step
-    and add the spherical cap approximation
-    '''
-
-    plt.close("all")
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    fig = plt.figure(figsize=(12,6))
-
-    ax = fig.add_subplot(111,aspect='equal')
-
-
-    # plot the contour for the last timestep and
-    # compute the y_min of the contour giving
-    # the wall position
-    y_min = 0.0
-    y_max = 0.0
-
-    dataPath = os.path.join(dataRootPath,'contours'+str(timestep)+'.curve')
-
-    if(os.path.isfile(dataPath)):
-
-        data = np.loadtxt(dataPath)
-        
-        plotstyle = '-'
-        linewidth = width
-        color = grayscale_to_RGB(1.0)
-        
-        plt.plot(
-            data[:,0],
-            data[:,1],
-            plotstyle,
-            linewidth=linewidth,
-            color=color)
-        
-        y_min = min(y_min,min(data[:,1]))
-        y_max = max(y_max,max(data[:,1]))
-        
-    y_max = 1.05*y_max
-
-    plt.ylim([y_min,y_max])
-
-
-    # plot the spherical cap
-    dataPath = os.path.join(dataRootPath,'volume.txt')
-    volume = np.loadtxt(dataPath)
-
-    theta = (180.0-contactAngle)*pi/180.0
-    Ri = sqrt(2.0*volume[-1,2]/pi)
-        
-    dataPath = os.path.join(dataRootPath,'domain_borders.txt')
-    domain_borders = extract_domain_borders(dataPath)
-
-    x_min = data[ 0,0]*1.5
-    x_max = data[-1,0]*1.5
-    y_min = domain_borders['y_min']+2.0*domain_borders['dy']
-    y_max = y_max*1.1
-
-    #x_min = -0.35
-    #x_max =  0.35
-
-    if(contactAngle<90):
-        sph_data = get_spherical_cap_data(y_min,x_min,x_max,Ri,theta,filled=True)
-        
-    else:
-        sph_data = get_spherical_cap_data(y_min,x_min,x_max,Ri,theta,filled=False)
-    
-
-    #eq_lgh = get_equilibrium_length(Ri,theta)
-    #print 'eq_lgh: ', 2.0*eq_lgh
-
-    plt.plot(
-        sph_data[0],
-        sph_data[1],
-        '--',
-        linewidth=width,
-        color='red')
-    plt.ylim([y_min,y_max])
-
-    if(x_limits!='None'):
-        plt.xlim(x_limits)
-
-    if(y_limits!='None'):
-        plt.ylim(y_limits)
-    
-    ax.set_xlabel(r''+xlabel)
-    ax.set_ylabel(r''+ylabel)
-
-            
-    # show the graph
-    if(show):
-        plt.show()
-        plt.close()
-
-                
-    # save in .eps format
-    if(not figPath==''):
-        plt.savefig(figPath)
-
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh b/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
deleted file mode 100644
index ffc4384..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_extract_contours.sh
+++ /dev/null
@@ -1,214 +0,0 @@
-#!/bin/bash
-
-pythonDir=/home/jdesmarais/Code/augeanstables/scripts_py
-
-# directory for the simulation at (T,ca)
-get_st_dir(){
-    projectDir=/home/jdesmarais/projects/20150708_dim2d_0.95_ca22.5-135.0_vap
-    dir="$projectDir/dim2d_"$1"_ca"$2"_vap"
-    echo "$dir"
-}
-
-# generate the contours for steady state simulations
-generate_st_contours(){
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    inputDir=$( get_st_dir $1 $2)
-    ca=$2
-    scaling=$6
-
-    options="-i $inputDir -c $ca -t $3 -p -g -r -w -l max_gradient"
-    #options="-i $inputDir -c $ca -t $3 -r -l max_gradient -s -x $4 -y $5 -a $scaling"
-
-    ./extract_bubble_contours.py $options #> cur_st_contours.out 2>&1
-
-    #mv cur_st_contours.out $inputDir/contours
-
-    echo "=================================================="
-    echo "generate_st_contours( "$T" , "$ca" ) : done"
-    echo "=================================================="
-    echo ''
-}
-
-
-# directory for the nucleation simulation on
-# uniform surface at (T,ca,sh)
-get_nucleation_dir(){
-    projectDir=/home/jdesmarais/projects/
-    dir="$projectDir/dim2d_"$1"_ca"$2"_vap_fh"$3
-    echo "$dir"
-}
-
-
-# generate the contours for the uniform surface nucleation simulations
-generate_nucleation_contours(){
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    inputDir=$( get_nucleation_dir $1 $2 $3 )
-    ca=$2
-
-    #options="-i $inputDir -c $ca -t $4 -x $5 -y $6 -p -l max_gradient -g -r -w"
-    options="-i $inputDir -c $ca -t $4 -x $5 -y $6 -p -l wall_max_gradient -s -r"
-
-    ./extract_bubble_contours.py $options
-
-    echo "=================================================="
-    echo "generate_contours( "$1" , "$2" , "$3" ) : done"
-    echo "=================================================="
-    echo ''
-}
-
-
-# directory for the nucleation simulation on
-# uniform surface at (T,ca,sh)
-get_inflow_sph_dir(){
-    projectDir=/home/jdesmarais/projects
-    dir="$projectDir/dim2d_"$1"_ca"$2"_vap_v"$3"_hca"$4"_sph"
-    echo "$dir"
-}
-
-
-# generate the contours for the uniform surface nucleation simulations
-generate_inflow_sph_contours(){
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    T=$1
-    ca=$2
-    v=$3
-    hca=$4
-
-    inputDir=$( get_inflow_sph_dir $T $ca $v $hca)
-
-    
-    #options="-i $inputDir -c $ca -t $5 -x $6 -y $7 -p -l max_gradient -g -w"
-    options="-i $inputDir -c $ca -t $5 -x $6 -y $7 -p -l max_gradient -s"
-
-    ./extract_bubble_contours.py  $options #>cur_contours.out 2>&1
-
-
-    echo "=================================================="
-    echo "generate_contours( "$T" , "$ca" , "$v", "$hca" ) : done"
-    echo "=================================================="
-    echo ''
-}
-
-
-# directory for the nucleation simulation on
-# uniform surface at (T,ca,sh)
-get_linear_inflow_sph_dir(){
-    projectDir=/home/jdesmarais/projects
-    dir="$projectDir/dim2d_"$1"_ca"$2"_vap_vl"$3"_hca"$4"_sph"
-    echo "$dir"
-}
-
-
-# generate the contours for the uniform surface nucleation simulations
-generate_linear_inflow_sph_contours(){
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    T=$1
-    ca=$2
-    v=$3
-    hca=$4
-
-    inputDir=$( get_linear_inflow_sph_dir $T $ca $v $hca)
-
-    
-    #options="-i $inputDir -c $ca -t $5 -x $6 -y $7 -p -l max_gradient -g -w"
-    options="-i $inputDir -c $ca -t $5 -x $6 -y $7 -p -l max_gradient -s"
-
-    ./extract_bubble_contours.py  $options #>cur_contours.out 2>&1
-
-
-    echo "=================================================="
-    echo "generate_contours( "$T" , "$ca" , "$v", "$hca" ) : done"
-    echo "=================================================="
-    echo ''
-}
-
-
-# directory for the nucleation simulation on
-# uniform surface at (T,ca,sh)
-get_inflow_nucleation_dir(){
-    projectDir=/home/jdesmarais/projects
-    dir="$projectDir/dim2d_"$1"_ca"$2"_vap_fh"$3"_v"$4"_hca"$5
-    echo "$dir"
-}
-
-
-# generate the contours for the uniform surface nucleation simulations
-generate_inflow_nucleation_contours(){
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    T=$1
-    ca=$2
-    sh=$3
-    v=$4
-    hca=$5
-
-    inputDir=$( get_inflow_nucleation_dir $T $ca $sh $v $hca)
-
-    
-    #options="-i $inputDir -c $ca -t $6 -x $7 -y $8 -p -l max_gradient -g -w"
-    options="-i $inputDir -c $ca -t $6 -x $7 -y $8 -p -l max_gradient -s"
-
-    ./extract_bubble_contours.py  $options #>cur_contours.out 2>&1
-
-
-    echo "======================================================="
-    echo "generate_contours( "$T" , "$ca" , "$sh", "$v", "$hca" ) : done"
-    echo "======================================================="
-    echo ''
-}
-
-
-# directory for the nucleation simulation on
-# uniform surface at (T,ca,sh)
-get_linear_inflow_nucleation_dir(){
-    projectDir=/home/jdesmarais/projects
-
-    if [ $4 != "0.0" ]
-    then
-	dir="$projectDir/dim2d_"$1"_ca"$2"_vap_fh"$3"_vl"$4"_hca"$5
-    else
-	dir="$projectDir/dim2d_"$1"_ca"$2"_vap_fh"$3"_hca"$5
-    fi
-    echo "$dir"
-}
-
-
-# generate the contours for the uniform surface nucleation simulations
-generate_linear_inflow_nucleation_contours(){
-
-    cd $pythonDir
-    cd wall_steady_state_automatization/contours_extraction
-
-    T=$1
-    ca=$2
-    sh=$3
-    v=$4
-    hca=$5
-
-    inputDir=$( get_linear_inflow_nucleation_dir $T $ca $sh $v $hca)
-    
-    options="-i $inputDir -c $ca -t $6 -x $7 -y $8 -p -l max_gradient -g -w -r"
-    #options="-i $inputDir -c $ca -t $6 -x $7 -y $8 -p -l max_gradient -s"
-
-    ./extract_bubble_contours.py  $options
-
-
-    echo "======================================================="
-    echo "generate_contours( "$T" , "$ca" , "$sh", "$v", "$hca" ) : done"
-    echo "======================================================="
-    echo ''
-}
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_mass_contours.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_mass_contours.py
deleted file mode 100644
index e85cba1..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_mass_contours.py
+++ /dev/null
@@ -1,119 +0,0 @@
-#!/usr/bin/python
-
-from math import factorial
-import numpy as np
-import os
-import matplotlib.pyplot as plt
-
-
-
-def savitzky_golay(y, window_size, order, deriv=0, rate=1):
-    r"""Smooth (and optionally differentiate) data with a Savitzky-Golay filter.
-    The Savitzky-Golay filter removes high frequency noise from data.
-    It has the advantage of preserving the original shape and
-    features of the signal better than other types of filtering
-    approaches, such as moving averages techniques.
-    Parameters
-    ----------
-    y : array_like, shape (N,)
-        the values of the time history of the signal.
-    window_size : int
-        the length of the window. Must be an odd integer number.
-    order : int
-        the order of the polynomial used in the filtering.
-        Must be less then `window_size` - 1.
-    deriv: int
-        the order of the derivative to compute (default = 0 means only smoothing)
-    Returns
-    -------
-    ys : ndarray, shape (N)
-        the smoothed signal (or it's n-th derivative).
-    Notes
-    -----
-    The Savitzky-Golay is a type of low-pass filter, particularly
-    suited for smoothing noisy data. The main idea behind this
-    approach is to make for each point a least-square fit with a
-    polynomial of high order over a odd-sized window centered at
-    the point.
-    Examples
-    --------
-    t = np.linspace(-4, 4, 500)
-    y = np.exp( -t**2 ) + np.random.normal(0, 0.05, t.shape)
-    ysg = savitzky_golay(y, window_size=31, order=4)
-    import matplotlib.pyplot as plt
-    plt.plot(t, y, label='Noisy signal')
-    plt.plot(t, np.exp(-t**2), 'k', lw=1.5, label='Original signal')
-    plt.plot(t, ysg, 'r', label='Filtered signal')
-    plt.legend()
-    plt.show()
-    References
-    ----------
-    .. [1] A. Savitzky, M. J. E. Golay, Smoothing and Differentiation of
-       Data by Simplified Least Squares Procedures. Analytical
-       Chemistry, 1964, 36 (8), pp 1627-1639.
-    .. [2] Numerical Recipes 3rd Edition: The Art of Scientific Computing
-       W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery
-       Cambridge University Press ISBN-13: 9780521880688
-    """
-    
-
-    try:
-        window_size = np.abs(np.int(window_size))
-        order = np.abs(np.int(order))
-    except ValueError, msg:
-        raise ValueError("window_size and order have to be of type int")
-    if window_size % 2 != 1 or window_size < 1:
-        raise TypeError("window_size size must be a positive odd number")
-    if window_size < order + 2:
-        raise TypeError("window_size is too small for the polynomials order")
-    order_range = range(order+1)
-    half_window = (window_size -1) // 2
-    # precompute coefficients
-    b = np.mat([[k**i for i in order_range] for k in range(-half_window, half_window+1)])
-    m = np.linalg.pinv(b).A[deriv] * rate**deriv * factorial(deriv)
-    # pad the signal at the extremes with
-    # values taken from the signal itself
-    firstvals = y[0] - np.abs( y[1:half_window+1][::-1] - y[0] )
-    lastvals = y[-1] + np.abs(y[-half_window-1:-1][::-1] - y[-1])
-    y = np.concatenate((firstvals, y, lastvals))
-    return np.convolve( m[::-1], y, mode='valid')
-
-
-def apply_filter_to_contour_mass(mass):
-    '''
-    @description:
-    apply the filter to the mass
-    '''
-
-    mass_filter = savitzky_golay(mass[2:90,2], 19, 3, deriv=0, rate=1)
-
-    fig = plt.figure(figsize=(8,6))
-    ax = fig.add_subplot(111)
-
-    plt.plot(mass[:,1],
-             mass[:,2],
-             '+-',
-             linewidth=3,
-             color='blue')
-
-    plt.plot(mass[2:90,1],
-             mass_filter,
-             '-',
-             linewidth=3,
-             color='red')
-
-    plt.show()
-    plt.close()
-    
-
-if __name__=="__main__":
-    
-    dirPath = os.path.join('/home/jdesmarais/projects',
-                           '20150624_dim2d_0.95_ca22.5-135.0_vap_sh-0.02-0.1',
-                           'dim2d_0.95_ca22.5_vap_sh-0.02')
-
-    filePath = os.path.join(dirPath,'contours','contour.txt')
-
-    mass = np.loadtxt(filePath)
-
-    apply_filter_to_contour_mass(mass)
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_messages.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_messages.py
deleted file mode 100644
index 964df77..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_messages.py
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/usr/bin/python -i
-
-import sys
-
-def create_mg_progress(mg_progress):
-    '''
-    @description:
-    print a message which is overwritten
-    '''
-    sys.stdout.write('%s\r' % mg_progress)
-    sys.stdout.flush()
-
-
-def create_mg_final(mg_progress):
-    '''
-    @description:
-    print a message which is not overwritten
-    '''
-    sys.stdout.write('%s' % mg_progress)
-    sys.stdout.flush()
-    print '\n'
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_nc_to_vtklines.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_nc_to_vtklines.py
deleted file mode 100644
index 62e8a55..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_nc_to_vtklines.py
+++ /dev/null
@@ -1,1049 +0,0 @@
-#!/usr/bin/python -i
-
-import sys
-import inspect
-import os
-import getopt
-sys.path.append(os.environ['VISIT_PYTHON_LIB'])
-import visit
-import time
-
-from library_vtklines_to_curve_positions import get_curve_coords_from_vtkfile
-from math import sqrt
-
-import numpy as np
-
-# add the python files from sm_lg_automatization
-cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(\
-    os.path.split(
-    inspect.getfile( inspect.currentframe() ))[0],"../../sm_lg_domain_automatization")))
-if cmd_subfolder not in sys.path:
-    sys.path.insert(0, cmd_subfolder)
-
-from library_sm_lg_inputs import (get_mass_density_vapor,
-                                  get_mass_density_liquid,
-                                  get_interface_length)
-
-from automatization_contours_csts import cv_r,we
-
-from library_messages import create_mg_progress, create_mg_final
-
-
-debug = False
-add_sleep  = debug
-time_sleep = 3.0
-
-
-def get_x_reflection(domain_borders,bc_size=2):
-
-    x_reflection = domain_borders['x_min']+bc_size*domain_borders['dx']
-
-    return x_reflection
-
-
-def compute_volume(massLim,domain_borders,reflection=False):
-    '''
-    @description: compute the volume of
-    the contours using trapezoid rule
-    '''
-
-    # create a variable which is equal to the 1.0
-    # inside the vapor phase and equal to 0 in the
-    # liquid phase
-    visit.DefineScalarExpression("vap_phase", "if( le(mass,"+str(massLim)+") , 1, 0)")
-    visit.AddPlot("Pseudocolor","vap_phase", 1, 1)
-
-    remove_boundary_pts(domain_borders)
-
-    if(reflection):
-        x_reflection = get_x_reflection(domain_borders)
-        add_reflection_x(x_reflection)
-
-    visit.DrawPlots()
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-
-    # in this way the volume contained in the "bubble"
-    # is simply the sum of the volume over the entire
-    # domain
-    totalVolume = visit.Query("Weighted Variable Sum")
-    try:
-        totalVolume = float(totalVolume.split('is')[1].split('(')[0])
-    except ValueError:
-        print 'library_nc_to_vtklines'
-        print 'compute_volume'
-        print 'error when reading totalVolume'
-        print totalVolume
-        sys.exit(2)
-
-    # remove the plots
-    visit.RemoveOperator(0,1)
-    visit.DeleteActivePlots()
-
-    return totalVolume
-
-
-def compute_mass(massLim,domain_borders,reflection=False):
-    '''
-    @description:
-    define a variable which is 1.0 inside the
-    contour and 0 outside, and perform a weighted
-    sum of the variable over the domain
-    '''
-
-    # create a variable which is equal to the mass
-    # inside the vapor phase and equal to 0 in the
-    # liquid phase
-    visit.DefineScalarExpression("vap_phase", "if( le(mass,"+str(massLim)+") , mass, 0)")
-    visit.AddPlot("Pseudocolor","vap_phase", 1, 1)
-
-    remove_boundary_pts(domain_borders)
-
-    if(reflection):
-        x_reflection = get_x_reflection(domain_borders)
-        add_reflection_x(x_reflection)
-
-    visit.DrawPlots()
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-
-    # in this way the mass contained in the "bubble"
-    # is simply the sum of the mass over the entire
-    # domain
-    totalMass = visit.Query("Weighted Variable Sum")
-    try:
-        totalMass = float(totalMass.split('is')[1].split('(')[0])
-    except ValueError:
-        print 'library_nc_to_vtklines'
-        print 'compute_mass'
-        print 'error when reading totalMass'
-        print totalMass
-        sys.exit(2)
-
-    # remove the plots
-    visit.RemoveOperator(0,1)
-    visit.DeleteActivePlots()
-
-    return totalMass
-
-
-def get_time(ncPath):
-    '''
-    @description:
-    extract the time from the database
-    '''
-
-    md = visit.GetMetaData(ncPath)
-    return float(md.times[0])
-
-
-def get_plot_range():
-    '''
-    @description:
-    extract plot range of the current plot
-    '''
-    
-    minVar = visit.Query('Min')
-    maxVar = visit.Query('Max')
-
-    minVar = float(minVar.split('=')[1].split('(')[0])
-    maxVar = float(maxVar.split('=')[1].split('(')[0])
-
-    return [minVar,maxVar]
-
-
-def get_nb_nodes():
-    '''
-    @description:
-    extract the number of nodes
-    '''
-
-    nbNodes = visit.Query('NumNodes')
-    nbNodes = int(nbNodes.split('is')[1].split('.')[0])
-
-    return nbNodes
-
-
-def get_domain_borders():
-    '''
-    @description:
-    extract the [x_min,x_max,y_min,y_max] of the
-    domain plotted    
-    '''
-    
-    visit.AddPlot("Curve", "x", 1, 1)
-    visit.DrawPlots()
-    [x_min,x_max] = get_plot_range()
-    nx = get_nb_nodes()
-    visit.DeleteActivePlots()
-
-    visit.AddPlot("Curve", "y", 1, 1)
-    visit.DrawPlots()
-    [y_min,y_max] = get_plot_range()
-    ny = get_nb_nodes()
-    visit.DeleteActivePlots()
-
-    dx = (x_max-x_min)/(nx-1)
-    dy = (y_max-y_min)/(ny-1)
-
-    domain_borders = {}
-    domain_borders['nx']=nx
-    domain_borders['ny']=ny
-    domain_borders['dx']=dx
-    domain_borders['dy']=dy
-    domain_borders['x_min']=x_min
-    domain_borders['x_max']=x_max
-    domain_borders['y_min']=y_min
-    domain_borders['y_max']=y_max    
-
-    return domain_borders
-    
-
-def get_var_range(var):
-    '''
-    @description: extract the min,max,mid values
-    of a variable by first plotting the pseudocolor
-    plot, extracting the min and max values and 
-    computing the middle value
-    '''
-    
-    visit.AddPlot("Pseudocolor",var, 1, 1)
-    visit.DrawPlots()
-
-    [minVar,maxVar] = get_plot_range()
-
-    visit.DeleteActivePlots()
-
-    midVar = 0.5*(minVar+maxVar)
-
-    return [minVar,maxVar,midVar]
-
-
-def get_max_grad(domain_borders):
-    '''
-    @description: extract the maximum of the gradient norm
-    in the interior domain
-    '''
-
-    visit.DefineScalarExpression("mass_grad_x", "gradient(mass)[0]")
-    visit.DefineScalarExpression("mass_grad_y", "gradient(mass)[1]")
-    visit.DefineScalarExpression("mass_grad"  , "sqrt(mass_grad_x^2+mass_grad_y^2)")
-    visit.AddPlot("Pseudocolor","mass_grad", 1, 1)
-
-    remove_boundary_pts(domain_borders,bc_size=2)
-
-    visit.DrawPlots()
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-
-    gradMass = visit.Query('Max', use_actual_data=1)
-
-    coord1 = float(gradMass.split(',')[0].split('<')[1])
-    coord2 = float(gradMass.split(',')[1].split('>')[0])
-
-    gradMass = float(gradMass.split('=')[1].split('(')[0])
-
-    visit.DeleteActivePlots()
-
-    return [coord1,coord2,gradMass]
-
-
-def get_max_grad_at_wall(domain_borders):
-    '''
-    @description: extract the maximum of the gradient norm
-    in the interior domain near the wall
-    '''
-
-    visit.DefineScalarExpression("mass_grad_x", "gradient(mass)[0]")
-    visit.DefineScalarExpression("mass_grad_y", "gradient(mass)[1]")
-    visit.DefineScalarExpression("mass_grad"  , "sqrt(mass_grad_x^2+mass_grad_y^2)")
-    visit.AddPlot("Pseudocolor","mass_grad", 1, 1)
-
-    visit.AddOperator("Box",1)
-    BoxAtts = visit.BoxAttributes()
-    BoxAtts.amount = BoxAtts.All
-    BoxAtts.minx = domain_borders['x_min']+2.5*domain_borders['dx']
-    BoxAtts.maxx = domain_borders['x_max']-2.5*domain_borders['dx']
-    BoxAtts.miny = domain_borders['y_min']+2.5*domain_borders['dy']
-    BoxAtts.maxy = domain_borders['y_min']+4.5*domain_borders['dy']
-    BoxAtts.inverse = 0
-    visit.SetOperatorOptions(BoxAtts,1)
-
-    visit.DrawPlots()
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-
-    gradMass = visit.Query('Max', use_actual_data=1)
-
-    coord1 = float(gradMass.split(',')[0].split('<')[1])
-    coord2 = float(gradMass.split(',')[1].split('>')[0])
-
-    gradMass = float(gradMass.split('=')[1].split('(')[0])
-
-    visit.DeleteActivePlots()
-
-    return [coord1,coord2,gradMass]
-
-
-def get_mass_for_contour(coord1,coord2,gradMass,phase_check):
-    '''
-    @description: extraction of the mass at [coord1,coord2]
-    and phase verification if enabled
-    '''
-
-    #=========================================================
-    # extract the mass at the location of the maximum gradient
-    #=========================================================
-    visit.AddPlot("Pseudocolor","mass", 1, 1)
-    visit.DrawPlots()
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-
-    midMass = visit.NodePick(coord=(coord1,coord2,0),
-                             vars=("default","mass"))
-    midMass = midMass['mass']
-
-    visit.DeleteActivePlots()
-
-
-    #====================================================
-    # determine the temperature at the interface location
-    #====================================================
-    # definition of the kortweg energy
-    visit.DefineScalarExpression("mass_grad_squared", "mass_grad_x^2+mass_grad_y^2")
-    visit.DefineScalarExpression("we", str(we))
-    visit.DefineScalarExpression("korteweg_energy", "0.5/we*mass_grad_squared")
-    
-    # definition of the kinetic energy
-    visit.DefineScalarExpression("velocity_x", "momentum_x/mass")
-    visit.DefineScalarExpression("velocity_y", "momentum_y/mass")
-    visit.DefineScalarExpression("kinetic_energy", "0.5*mass*(velocity_x^2+velocity_y^2)")
-    
-    # definition of the temperature
-    visit.DefineScalarExpression("cv_r", str(cv_r))
-    visit.DefineScalarExpression("temperature", "3/(8*cv_r)*(1/mass*(energy-kinetic_energy-korteweg_energy)+3*mass)")
-    
-    # draw the temperature and extract the temperature at the maximum gradient point
-    visit.AddPlot("Pseudocolor","temperature", 1, 1)
-    visit.DrawPlots()
-
-    midTemperature = visit.NodePick(coord=(coord1,coord2,0), vars=("default","temperature"))
-    midTemperature = midTemperature['temperature']
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-        print midTemperature
-
-    visit.DeleteActivePlots()
-
-
-    #====================================================
-    # determine the norm of the temperature gradient
-    # at the interface location
-    #====================================================
-    # definition of the temperature gradient
-    visit.DefineScalarExpression("dTdx", "gradient(temperature)[0]")
-    visit.DefineScalarExpression("dTdy", "gradient(temperature)[1]")
-    visit.DefineScalarExpression("temperature_grad_norm", "sqrt(dTdx^2+dTdy^2)")
-
-    visit.AddPlot("Pseudocolor","temperature_grad_norm", 1, 1)
-    visit.DrawPlots()
-
-    midTemperatureGrad = visit.NodePick(coord=(coord1,coord2,0), vars=("default","temperature_grad_norm"))
-    midTemperatureGrad = midTemperatureGrad['temperature_grad_norm']
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-        print midTemperatureGrad
-
-    visit.DeleteActivePlots()
-
-
-    #==========================================================
-    # if the phase check is enabled, determine whether the mass
-    # density extracted corresponds to a potential mass density
-    # at the location of the interface
-    #==========================================================
-    if(phase_check):
-    
-        # deduce the mass densities of the liquid and vapor phases at this temperature
-        mass_vap = get_mass_density_vapor(midTemperature)
-        mass_liq = get_mass_density_liquid(midTemperature)
-    
-        # check whether the mass density extracted is close enough from the
-        # mid mass density
-        mid_mass_c = 0.5*(mass_vap+mass_liq)
-        check = abs((midMass-mid_mass_c)/(mass_liq-mass_vap)) < 0.4
-
-        if(add_sleep):
-            print 'check_mass: ', check
-    
-        # check by comparing the maximum gradient of the mass density
-        interface_lgh = get_interface_length(we,midTemperature)
-        mid_gradMass = abs((mass_liq-mass_vap)/interface_lgh)
-        check_grad = (abs(gradMass)>0.95*mid_gradMass) #0.9
-
-        if(debug):
-            print 'check_md_grad: ', (abs(gradMass)>0.9*mid_gradMass)
-            print 'diff: ', abs(gradMass)/mid_gradMass
-
-        check = check and check_grad
-
-    else:
-        check = True
-    
-
-    return [midMass,check,midTemperature,midTemperatureGrad]
-
-
-def get_mid_by_max_grad(domain_borders,phase_check=False):
-    '''
-    @description: extract the mass density at the
-    interface between the liquid and vapor phases
-    by extracting the mass at the location where
-    the maximum mass density gradient is reached
-    '''
-
-    # extract the location of the maximum gradient for the mass
-    [coord1,coord2,gradMass] = get_max_grad(domain_borders)
-
-
-    # extract the mass at the location of the maximum gradient
-    # and check whether it is an interface
-    if(gradMass!=0.0):
-
-        [midMass,check,temperature,temperatureGrad] = get_mass_for_contour(coord1,coord2,gradMass,phase_check)
-
-    else:
-        midMass = 0.0
-        check = False
-        temperature=0.0
-        temperatureGrad=0.0
-
-    return [midMass,check,temperature,temperatureGrad]
-
-
-def get_mid_by_max_grad_at_wall(domain_borders,phase_check=False):
-    '''
-    @description: extract the mass density at the
-    interface between the liquid and vapor phases
-    by extracting the mass at the location where
-    the maximum mass denisty gradient alogn the wall
-    is reached    
-    '''
-
-    # extract the location of the maximum gradient for the mass
-    [coord1,coord2,gradMass] = get_max_grad_at_wall(domain_borders)
-
-
-    # extract the mass at the location of the maximum gradient
-    # and check whether it is an interface
-    if(gradMass!=0.0):
-
-        [midMass,check,temperature,temperatureGrad] = get_mass_for_contour(coord1,coord2,gradMass,phase_check)
-
-    else:
-        midMass = 0.0
-        check = False
-        temperature=0.0
-        temperatureGrad=0.0
-
-    return [midMass,check,temperature,temperatureGrad]
-
-
-    #visit.DefineScalarExpression("mass_grad_x", "gradient(mass)[0]")
-    #visit.AddPlot("Pseudocolor","mass_grad_x", 1, 1)
-    #
-    #visit.AddOperator("Box",1)
-    #BoxAtts = visit.BoxAttributes()
-    #BoxAtts.amount = BoxAtts.All
-    #BoxAtts.minx = domain_borders['x_min']
-    #BoxAtts.maxx = domain_borders['x_max']
-    #BoxAtts.miny = domain_borders['y_min']+1.5*domain_borders['dy']
-    #BoxAtts.maxy = domain_borders['y_min']+3.5*domain_borders['dy']
-    #BoxAtts.inverse = 0
-    #visit.SetOperatorOptions(BoxAtts,1)
-    #
-    #visit.DrawPlots()
-    #
-    #gradxMass = visit.Query('Max', use_actual_data=1)
-    #coord1 = float(gradxMass.split(',')[0].split('<')[1])
-    #coord2 = float(gradxMass.split(',')[1].split('>')[0])
-    #
-    #grad_x_Mass = float(gradxMass.split('=')[1].split('(')[0])
-    #
-    #visit.DeleteActivePlots()
-    #
-    #linearInterpolation=(grad_x_Mass!=0.0)
-    #
-    #if(grad_x_Mass!=0.0):       
-    #
-    #	if(linearInterpolation):
-    #	    # two points are needed for the linear interpolation
-    #	    # these are the points next to the node where the maximum
-    #	    # mass gradient along x is reached
-    #	    coord1_int0 = coord1-domain_borders['dx']
-    #	    coord1_int1 = coord1+domain_borders['dx']
-    #	    
-    #	    # we need to find the coordinates where the maximum
-    #	    # gradient is reached by d2mass/dx2 = 0 using linear
-    #	    # interpolation between the two previous points
-    #	    visit.DefineScalarExpression("mass_grad_xx", "gradient(mass_grad_x)[0]")
-    #	    visit.AddPlot("Pseudocolor","mass_grad_xx", 1, 1)
-    #	    visit.DrawPlots()
-    #	
-    #	    massGradXX_0 = visit.NodePick(
-    #	        coord=(coord1_int0,coord2,0),
-    #	        vars=("default","mass_grad_xx"))
-    #	    massGradXX_0 = massGradXX_0['mass_grad_xx']
-    #	
-    #	    massGradXX_1 = visit.NodePick(
-    #	        coord=(coord1_int1,coord2,0),
-    #	        vars=("default","mass_grad_xx"))
-    #	    massGradXX_1 = massGradXX_1['mass_grad_xx']
-    #	
-    #	    coord1 = coord1_int0 - massGradXX_0*(coord1_int1-coord1_int0)/(massGradXX_1-massGradXX_0)
-    #	    visit.DeleteActivePlots()
-    #	
-    #	    # we need to determine the mass at the coord1
-    #	    # using linear interpolation
-    #	    visit.AddPlot("Pseudocolor","mass", 1, 1)
-    #	    visit.DrawPlots()
-    #	
-    #	    mass_0 = visit.NodePick(
-    #	        coord=(coord1_int0,coord2,0),
-    #	        vars=("default","mass"))
-    #        mass_0 = mass_0['mass']
-    #	
-    #	    mass_1 = visit.NodePick(
-    #	        coord=(coord1_int1,coord2,0),
-    #	        vars=("default","mass"))
-    #        mass_1 = mass_1['mass']
-    #	
-    #	    midMass = mass_0 + (mass_1-mass_0)/(coord1_int1-coord1_int0)*(coord1-coord1_int0)
-    #	
-    #	    visit.DeleteActivePlots()
-    #	
-    #	else:
-    #	
-    #	    midMass = visit.NodePick(coord=(coord1,coord2,0), vars=("default","mass"))        
-    #	    midMass = midMass['mass']
-    #	
-    #	if(phase_check):
-    #	
-    #	    # definition of the kortweg energy
-    #	    visit.DefineScalarExpression("mass_grad_y", "gradient(mass)[1]")
-    #	    visit.DefineScalarExpression("mass_grad_squared", "mass_grad_x^2+mass_grad_y^2")
-    #	    visit.DefineScalarExpression("we", str(we))
-    #	    visit.DefineScalarExpression("korteweg_energy", "0.5/we*mass_grad_squared")
-    #	
-    #	    # definition of the kinetic energy
-    #	    visit.DefineScalarExpression("velocity_x", "momentum_x/mass")
-    #	    visit.DefineScalarExpression("velocity_y", "momentum_y/mass")
-    #	    visit.DefineScalarExpression("kinetic_energy", "0.5*mass*(velocity_x^2+velocity_y^2)")
-    #	
-    #	    # definition of the temperature
-    #	    visit.DefineScalarExpression("cv_r", str(cv_r))
-    #	    visit.DefineScalarExpression("temperature", "3/(8*cv_r)*(1/mass*(energy-kinetic_energy-korteweg_energy)+3*mass)")
-    #	
-    #	    # draw the temperature and extract the temperature at the maximum gradient point
-    #	    visit.AddPlot("Pseudocolor","temperature", 1, 1)
-    #	    visit.DrawPlots()
-    #	    midTemperature = visit.NodePick(coord=(coord1,coord2,0), vars=("default","temperature"))
-    #	    midTemperature = midTemperature['temperature']
-    #	    visit.DeleteActivePlots()
-    #	
-    #	    # deduce the mass densities of the liquid and vapor phases at this temperature
-    #	    mass_vap = get_mass_density_vapor(midTemperature)
-    #	    mass_liq = get_mass_density_liquid(midTemperature)
-    #	
-    #	    # check whether the mass density extracted is close enough from the
-    #	    # mid mass density
-    #	    mid_mass_c = 0.5*(mass_vap+mass_liq)
-    #	    check = abs((midMass-mid_mass_c)/(mass_liq-mass_vap)) < 0.2
-    #	
-    #	    # check with the norm of the mass density gradient
-    #	    visit.AddPlot("Pseudocolor","mass_grad_y", 1, 1)
-    #	    visit.DrawPlots()
-    #	    gradyMass = visit.NodePick(coord=(coord1,coord2,0), vars=("default","mass_grad_y"))
-    #	    grad_y_Mass = gradyMass['mass_grad_y']
-    #	    visit.DeleteActivePlots()
-    #	
-    #	    gradMassNorm = sqrt(grad_x_Mass**2+grad_y_Mass**2)
-    #	
-    #	    # check by comparing the maximum gradient of the mass density
-    #	    interface_lgh = get_interface_length(we,midTemperature)
-    #	    mid_gradMass = (mass_liq-mass_vap)/interface_lgh
-    #	    check = abs((gradMassNorm - mid_gradMass)/mid_gradMass) < 0.2
-    #
-    #	else:
-    #	
-    #	    check = True
-    #	
-    #	visit.RemoveOperator(0, 1)
-    #	visit.DeleteActivePlots()
-    #	visit.ClearPickPoints()
-    #
-    #else:
-    #    midMass = 0.0
-    #    check = False
-    #
-    #return [midMass,check]
-
-
-def add_contours(var,contourBorders):
-    '''
-    @description:
-    add one single contour
-    '''
-
-    visit.AddPlot("Contour", var, 1, 1)
-
-    ContourAtts = visit.ContourAttributes()
-    ContourAtts.changedColors = ()
-    ContourAtts.colorType = ContourAtts.ColorBySingleColor  # ColorBySingleColor, ColorByMultipleColors, ColorByColorTable
-    ContourAtts.colorTableName = "Default"
-    ContourAtts.invertColorTable = 0
-    ContourAtts.legendFlag = 1
-    ContourAtts.lineStyle = ContourAtts.SOLID  # SOLID, DASH, DOT, DOTDASH
-    ContourAtts.lineWidth = 1
-    ContourAtts.singleColor = (255, 0, 0, 255)
-    ContourAtts.contourNLevels = 1
-    ContourAtts.contourValue = ()
-    ContourAtts.contourPercent = ()
-    ContourAtts.contourMethod = ContourAtts.Level  # Level, Value, Percent
-    ContourAtts.minFlag = 1
-    ContourAtts.maxFlag = 1
-    ContourAtts.min = contourBorders[0]
-    ContourAtts.max = contourBorders[1]
-    ContourAtts.scaling = ContourAtts.Linear  # Linear, Log
-    ContourAtts.wireframe = 0
-    visit.SetPlotOptions(ContourAtts)
-
-
-def remove_boundary_pts(domain_borders,bc_size=2):
-    '''
-    @description:
-    remove the boundary points from the
-    computational domain
-    '''
-
-    x_min_R = domain_borders['x_min']+(bc_size)*domain_borders['dx']
-    x_max_R = domain_borders['x_max']-(bc_size)*domain_borders['dx']
-    y_min_R = domain_borders['y_min']+(bc_size)*domain_borders['dy']
-    y_max_R = domain_borders['y_max']-(bc_size)*domain_borders['dy']
-
-    visit.AddOperator("Box",1)
-    BoxAtts = visit.BoxAttributes()
-    BoxAtts.amount = BoxAtts.All #Some
-    BoxAtts.minx = x_min_R
-    BoxAtts.maxx = x_max_R
-    BoxAtts.miny = y_min_R
-    BoxAtts.maxy = y_max_R
-    BoxAtts.inverse = 0
-    visit.SetOperatorOptions(BoxAtts,1)
-
-
-def add_reflection_x(x_reflection):
-
-    visit.AddOperator("Reflect", 1)
-    ReflectAtts = visit.ReflectAttributes()
-    ReflectAtts.octant = ReflectAtts.PXPYPZ  # PXPYPZ, NXPYPZ, PXNYPZ, NXNYPZ, PXPYNZ, NXPYNZ, PXNYNZ, NXNYNZ
-    ReflectAtts.useXBoundary = 0
-    ReflectAtts.specifiedX = x_reflection
-    ReflectAtts.useYBoundary = 1
-    ReflectAtts.specifiedY = 0
-    ReflectAtts.useZBoundary = 1
-    ReflectAtts.specifiedZ = 0
-    ReflectAtts.reflections = (1, 1, 0, 0, 0, 0, 0, 0)
-    visit.SetOperatorOptions(ReflectAtts, 1)
-
-
-def generate_contours(var,domain_borders,contourBorders,reflection=False):
-    '''
-    @description: generate the contours
-    corresponding to the isosurfaces
-    of 'var' defined by contourBorders
-    '''
-
-    # plot the contour
-    add_contours(var,contourBorders)
-
-    # remove the boundary
-    #remove_boundary_pts(domain_borders,bc_size=bc_size)
-
-    # if reflection added, add a reflection operator
-    if(reflection):
-        x_reflection = get_x_reflection(domain_borders)
-        add_reflection_x(x_reflection)
-
-    visit.DrawPlots()
-
-    if(add_sleep):
-        time.sleep(time_sleep)
-
-
-def export_contours_to_vtk(vtkPath):
-    '''
-    @description: export the data of the plot
-    to vtk format
-    '''
-
-    outFile = os.path.basename(vtkPath)
-    outDir  = os.path.dirname(vtkPath)
-
-    ExportDBAtts = visit.ExportDBAttributes()
-    ExportDBAtts.allTimes = 0
-    ExportDBAtts.db_type = "VTK"
-    ExportDBAtts.db_type_fullname = "VTK_1.0"
-    ExportDBAtts.filename = outFile
-    ExportDBAtts.dirname = outDir
-    ExportDBAtts.variables = ()
-    ExportDBAtts.opts.types = (0)
-    visit.ExportDatabase(ExportDBAtts)
-
-
-def generate_vtklines(ncPath,
-                      contourRootPath,
-                      var='mass',
-                      contourPer=0.15,
-                      contourType='mass',
-                      phase_check=False,
-                      time=0,
-                      reflection=True):
-    '''
-    @description: generate the vtkfiles from a netcdf file
-    '''
-
-    visit.OpenDatabase("localhost:"+ncPath, 0)
-
-    vtkPath = 'contours'
-
-    domain_borders = get_domain_borders()
-
-    if(contourType=='mass'):
-
-        #extract [min,max,mid] for the mass
-        [minVar,maxVar,midVar] = get_var_range(var)
-        contourMin = midVar
-        contourMax = midVar
-
-    elif(contourType=='gradient'):
-
-        #extract [min,max,mid] for the Korteweg energy (0.5/We*(dm)^2)
-        visit.DefineScalarExpression("mass_grad_x", "gradient(mass)[0]")
-        visit.DefineScalarExpression("mass_grad_y", "gradient(mass)[1]")
-        visit.DefineScalarExpression("mass_grad_squared", "mass_grad_x^2+mass_grad_y^2")
-        [minVar,maxVar,midVar] = get_var_range("mass_grad_squared")
-        contourMin = maxVar*(1.0-contourPer)
-        contourMax = contourMin
-        var = 'mass_grad_squared'
-
-    elif(contourType=='wall_max_gradient'):
-                
-        [contourMin,
-         generateContours,
-         temperature,
-         temperatureGrad] = get_mid_by_max_grad_at_wall(domain_borders,
-                                                        phase_check=phase_check)
-        contourMax = contourMin
-
-    elif(contourType=='max_gradient'):
-                
-        [contourMin,
-         generateContours,
-         temperature,
-         temperatureGrad] = get_mid_by_max_grad(domain_borders,
-                                                phase_check=phase_check)
-        contourMax = contourMin
-
-    else:
-
-        print 'library_nc_to_vtklines'
-        print 'generate_vtklines'
-        print 'contourType not recognized'
-        sys.exit(2)
-
-    # choose to plot the contours corresponding to 
-    # a fixed mass density or corresponding to the 
-    # maximum gradient of the mass density
-    if(generateContours):
-
-        generate_contours(var,domain_borders,[contourMin,contourMax],reflection=reflection)
-
-        # export the contours to a vtk file
-        export_contours_to_vtk(vtkPath)
-
-        # get the coordinates of the contour
-        if(reflection):
-            
-            graph_data0 = get_curve_coords_from_vtkfile(
-                os.path.basename(vtkPath)+'.0.vtk')
-            
-            graph_data1 = get_curve_coords_from_vtkfile(
-                os.path.basename(vtkPath)+'.1.vtk')
-            
-            graph_data = []
-            graph_data.append([])
-            graph_data.append([])
-            graph_data[0] = graph_data1[0]+graph_data0[0]
-            graph_data[0].append(-graph_data1[0][0])
-            graph_data[1] = graph_data1[1]+graph_data0[1]
-            graph_data[1].append(graph_data1[1][0])
-            
-        else:
-            graph_data = get_curve_coords_from_vtkfile(
-                os.path.basename(vtkPath)+'.vtk')
-            
-        outfile=contourRootPath+str(time)+'.curve'
-        out = open(outfile, 'w')
-        for (x,y) in zip(graph_data[0],graph_data[1]):
-            out.write("%f %f\n" % (x,y))
-        out.close()
-
-        if(reflection):
-            os.remove(os.path.basename(vtkPath)+'.0.vtk',)
-            os.remove(os.path.basename(vtkPath)+'.1.vtk')
-        else:
-            os.remove(os.path.basename(vtkPath)+'.vtk')
-
-        #get the volume
-        volume = compute_volume(contourMin,domain_borders,reflection=reflection)
-
-        #get the mass
-        mass = compute_mass(contourMin,domain_borders,reflection=reflection)
-
-    else:
-        #no contours
-        graph_data='None'
-
-        #no volume
-        volume = 0.0
-
-        #no mass
-        mass = 0.0
-
-    visit.DeleteActivePlots()
-
-    return [graph_data,
-            volume,
-            mass,
-            temperature,
-            temperatureGrad,
-            contourMin,
-            domain_borders]
-
-
-def write_in_output_file(file_id,
-                         time,
-                         data,
-                         filepath):
-    '''
-    @description: write the content of the table
-    in an output file
-    '''
-
-    out = open(filepath, 'w')
-    for (i,t,v) in zip(file_id,time,data):
-        out.write("%f %f %f\n" % (i,t,v))
-    out.close()
-
-
-def generate_time_contour_data(ncRootPath,
-                               contourRootPath,
-                               timeRange=[0,1,1],
-                               var='mass',
-                               contourPer=0.15,
-                               contourType='mass',
-                               phase_check=False,
-                               reflection=True):
-
-    '''
-    @description: extract the surface contact between the bubble
-    and the wall as well as the volume of the bubble
-    '''
-    
-    
-    # create matrices of size timeRange[1]-timeRange[0]
-    # that will contain the time, contact length and volume
-    # of the bubble
-    nt = int(float(timeRange[1]-timeRange[0])/float(timeRange[2]))
-
-    file_id          = np.empty([nt])
-    time             = np.empty([nt])
-    contact_lgh      = np.empty([nt])
-    volume           = np.empty([nt])
-    mass             = np.empty([nt])
-    temperature      = np.empty([nt])
-    temperature_grad = np.empty([nt])
-    contour          = np.empty([nt])
-
-    mg_progress = 'generating contour files: ...'
-    create_mg_progress(mg_progress)
-    vtkRootPath = contourRootPath
-
-
-    # extract tha data as functions of time
-    for i in range(0,nt):
-
-        t = timeRange[0]+i*timeRange[2]
-
-        ncPath  = ncRootPath+str(t)+'.nc'
-        vtkPath = vtkRootPath+str(t)
-
-        if(not os.path.isfile(ncPath)):
-            print ncPath
-            break
-
-        # write the file id
-        file_id[i] = t
-
-        # extract the time
-        time[i] = get_time(ncPath)
-
-        # extract the graph data
-        [graph_data_t,
-         volume_t,
-         mass_t,
-         temperature_t,
-         temperature_grad_t,
-         contour_t,
-         domain_borders] = generate_vtklines(
-            ncPath,
-            contourRootPath,
-            var=var,
-            contourPer=contourPer,
-            contourType=contourType,
-            phase_check=phase_check,
-            time=t,
-            reflection=reflection)
-        
-        # save the volume at t
-        volume[i]= volume_t
-        if(debug):
-            print 'volume: ', volume_t
-
-        # save the mass at t
-        mass[i] = mass_t
-
-        # save the temperature at t
-        temperature[i] = temperature_t
-
-        # save the temperature gradient at t
-        temperature_grad[i] = temperature_grad_t
-
-        # save the mass density chosen
-        # for the contour
-        contour[i] = contour_t
-        
-        # determine the contact length
-        if(graph_data_t!='None'):
-
-            ## check whether the contour is a closed contour:
-            ## compare the distance to close the extreme points
-            ## in the contour and the grid size
-            #domain_ds  = sqrt(domain_borders['dx']**2+domain_borders['dy']**2)
-            #contour_ds = sqrt(
-            #    (graph_data_t[0][0] - graph_data_t[0][-1])**2 +\
-            #    (graph_data_t[1][0] - graph_data_t[1][-1])**2)
-            #
-            #closed_contour =  contour_ds < domain_ds*(1+0.1)
-
-            
-            # check which is the y of the lowest point in the contour
-            y = np.array(graph_data_t[1][:])
-            i_min, = np.unravel_index(y.argmin(),y.shape)
-            y_min = y[i_min]
-
-            # if this lowest point is above the wall limit,
-            # then the bubble is detached from the wall
-            if(y_min>(domain_borders['y_min']+2.0*domain_borders['dy'])): #+2*domain_borders['dy']
-                contact_lgh[i]=0.0
-
-            # otherwise, the bubble is attached to the wall
-            # we need to find the two points such that the
-            # bubble is attached to the wall, these are the
-            # extreme points in the contours (first and last)
-            else:
-                
-                x1 = graph_data_t[0][0]
-                x2 = graph_data_t[0][-1]
-
-                contact_lgh[i] = abs(x2-x1)
-
-        else:
-
-            contact_lgh[i]=0.0
-            
-
-        mg_progress = 'generating contour files: '+str(i+1)+' / '+str(nt)
-        create_mg_progress(mg_progress)
-
-    mg_progress = 'generating contour files: done              '
-    create_mg_final(mg_progress)
-
-
-    # write the volume(t) on an output file
-    write_in_output_file(
-        file_id,
-        time,
-        volume,
-        os.path.dirname(contourRootPath)+'/volume.txt')
-
-
-    # write the mass(t) on an output file
-    write_in_output_file(
-        file_id,
-        time,
-        mass,
-        os.path.dirname(contourRootPath)+'/mass.txt')
-
-
-    # write the temperature(t) on an output file
-    write_in_output_file(
-        file_id,
-        time,
-        temperature,
-        os.path.dirname(contourRootPath)+'/temperature.txt')
-
-
-    # write the temperature_grad(t) on an output file
-    write_in_output_file(
-        file_id,
-        time,
-        temperature_grad,
-        os.path.dirname(contourRootPath)+'/temperature_grad.txt')
-
-
-    # write the length(t) on an output file
-    write_in_output_file(
-        file_id,
-        time,
-        contact_lgh,
-        os.path.dirname(contourRootPath)+'/contact_lgh.txt')
-
-
-    # write the mass density chosen to draw the contour
-    # on an output file
-    write_in_output_file(
-        file_id,
-        time,
-        contour,
-        os.path.dirname(contourRootPath)+'/contour.txt')
-
-
-    # write the domain borders on an output file
-    out = open(os.path.dirname(contourRootPath)+'/domain_borders.txt', 'w')
-    out.write("%f\n" %(domain_borders['x_min']))
-    out.write("%f\n" %(domain_borders['x_max']))
-    out.write("%f\n" %(domain_borders['y_min']))
-    out.write("%f\n" %(domain_borders['y_max']))
-    out.write("%f\n" %(domain_borders['dx']))
-    out.write("%f\n" %(domain_borders['dy']))
-    out.close()
-    
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_volume.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_volume.py
deleted file mode 100644
index f4febbc..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_volume.py
+++ /dev/null
@@ -1,122 +0,0 @@
-#!/usr/bin/python
-
-
-import os
-import numpy as np
-
-from library_contact_lgh import (find_transition_indices,
-                                 interpolate_x_lim)
-
-
-def integrate_with_trapezoidal_rule(x_data,y_data):
-    '''
-    description:
-    integrate the volume under the curve using trapezoidal
-    rule
-    '''
-
-    volume = 0
-    
-    for i in range(0,len(x_data)-1):
-
-        volume+= (y_data[i] + 0.5*(y_data[i+1]-y_data[i]))*(x_data[i+1]-x_data[i])
-
-    return volume
-
-
-def compute_volume(x_data,y_data,y_lim):
-    '''
-    @description:
-    find the volume corresponding to the contour
-    '''
-
-    # find the i corresponding to the data
-    # next to the interaction with the wall
-    i_transition = find_transition_indices(x_data,y_data,y_lim)
-
-    if(len(i_transition)==0):
-        volume = 0
-
-    elif(len(i_transition)%2==0):
-        
-        volume = 0
-
-        for i in range(0,len(i_transition)/2):
-
-            # transition indices
-            i1 = i_transition[0+2*i]
-            i2 = i_transition[1+2*i]
-
-
-            # create the (xData,yData) needed to compute the volume
-            n = i2-i1+2
-
-            xData = np.empty([n])
-            yData = np.empty([n])
-            
-            xData[1:n-1] = x_data[i1+1:i2+1]
-            yData[1:n-1] = y_data[i1+1:i2+1]
-            
-            xData[0]   = interpolate_x_lim([x_data[i1],x_data[i1+1]],[y_data[i1],y_data[i1+1]],y_lim)
-            yData[0]   = y_lim
-            
-            xData[n-1] = interpolate_x_lim([x_data[i2],x_data[i2+1]],[y_data[i2],y_data[i2+1]],y_lim)
-            yData[n-1] = y_lim
-            
-
-            # compute the integral using trapezoidal rule
-            volume+= integrate_with_trapezoidal_rule(xData,yData)
-
-
-            # remove the volume belonging to the wall
-            volume-= y_lim*(xData[n-1]-xData[0])
-            
-    else:
-        print 'problem wen computing volume, i_transition: ', i_transition
-        volume = -1
-
-    return volume
-
-
-def curves_to_volume(dirPath,yWall=0.0):
-    '''
-    @description:
-    find the contact length from the contours
-    '''
-    
-    contourRootPath = os.path.join(dirPath,'contours')
-
-    contactLghPath = os.path.join(contourRootPath,'contact_lgh.txt')
-    contactLghData = np.loadtxt(contactLghPath)
-
-    nt = len(contactLghData[:,0])
-
-    volumeData = np.empty([nt])
-
-    
-    # compute the contact length for all the timesteps
-    for i in range(0,nt):
-
-        i_t = contactLghData[i,0]
-        t   = contactLghData[i,1]
-        
-        contourFile = 'contours'+str(int(i_t))+'.curve'
-
-        curvePath = os.path.join(contourRootPath,contourFile)
-
-        if(os.path.isfile(curvePath)):
-            curveData = np.loadtxt(curvePath)
-            volumeData[i] = compute_volume(curveData[:,0],
-                                           curveData[:,1],
-                                           yWall)
-
-        else:
-            volumeData[i] = 0.0
-
-
-    # write the volume(t) in an output file
-    out = open(os.path.join(contourRootPath,'volume_contact.txt'), 'w')
-    for (i,t,l) in zip(contactLghData[:,0],contactLghData[:,1],volumeData):
-        out.write("%f %f %f\n" % (i,t,l))
-    out.close()
-
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/library_vtklines_to_curve_positions.py b/scripts_py/wall_steady_state_automatization/contours_extraction/library_vtklines_to_curve_positions.py
deleted file mode 100644
index dc251a3..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/library_vtklines_to_curve_positions.py
+++ /dev/null
@@ -1,310 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description:
-most of the subroutines are originally from Jeremy Meredith,
-vtklines_to_curves.py created August 26, 2011. I modified it
-to get the position of the curve only instead of the values
-at the location of the curve
-'''
-
-import sys, os, math
-import matplotlib.pyplot as plt 
- 
-# ----------------------------------------------------------------------------
-#  Parse the points, line segments and cell or point scalars from a VTK file
-# ----------------------------------------------------------------------------
-def ParseFile(fn):
-    f = open(fn)
-    try:
-        npts = 0
-        pts = []
-        nlines = 0
-        lines = []
-        vals  = []
-        name  = "values"
-        ispoint = -1
-        # modes: 0 = searching for POINTS
-        #        1 = reading points
-        #        2 = looking for LINES
-        #        3 = reading lines
-        #        4 = looking for CELL_DATA, POINT_DATA, or SCALAR
-        #        5 = found scalar, skipping LOOKUP_TABLE
-        #        6 = reading scalar values
-        mode = 0
-        for l in f:
-            words = l.split()
-            if len(words) == 0:
-                None
-            elif mode == 0:
-                if words[0] == "POINTS":
-                    npts = int(words[1])
-                    if npts == 0:
-                        raise "Couldn't extract number of points"
-                    mode = 1
-            elif mode == 1:
-                for w in words:
-                    pts.append(float(w))
-                if len(pts) >= npts*3:
-                    mode = 2
-            elif mode == 2:
-                if words[0] == "LINES":
-                    nlines = int(words[1])
-                    if nlines == 0:
-                        raise "Couldn't extract number of lines"
-                    nints  =  int(words[2])
-                    if nints != 3*nlines:
-                        raise "Expected only 2-point line segments"
-                    mode = 3
-            elif mode == 3:
-                if int(words[0]) != 2:
-                    raise "Expected only 2-point line segments"
-                seg = [int(words[1]),int(words[2])]
-                lines.append(seg)
-                if len(lines) >= nlines:
-                    mode = 4
-            elif mode == 4:
-                if words[0] == "CELL_DATA":
-                    ispoint = 0
-                elif words[0] == "POINT_DATA":
-                    ispoint = 1
-                elif words[0] == "SCALARS":
-                    if ispoint < 0:
-                        raise "Found scalars before CELL_DATA or POINT_DATA"
-                    name = words[1]
-                    mode = 5
-            elif mode == 5:
-                if words[0] == "LOOKUP_TABLE":
-                    mode = 6
-            elif mode == 6:
-                for w in words:
-                    vals.append(float(w))
-                if ((ispoint==1 and len(vals) >= npts) or
-                    (ispoint==0 and len(vals) >= nlines)):
-                    mode = 7
-            else: # mode == 7
-                break
-    finally:
-        f.close()
-    return (name, ispoint, pts, lines, vals)
- 
-# ----------------------------------------------------------------------------
-#  Operations on points
-# ----------------------------------------------------------------------------
-def calcdist(pt0, pt1):
-    dx = pt0[0] - pt1[0]
-    dy = pt0[1] - pt1[1]
-    dz = pt0[2] - pt1[2]
-    dist = math.sqrt(dx*dx + dy*dy + dz*dz)
-    return dist
- 
-def calcmid(pt0, pt1):
-    x = (pt0[0] + pt1[0]) / 2.
-    y = (pt0[1] + pt1[1]) / 2.
-    z = (pt0[2] + pt1[2]) / 2.
-    return (x,y,z)
- 
-def getpoint(pts, i):
-    return (pts[3*i + 0], pts[3*i + 1], pts[3*i + 2])
- 
-
-#-----------------------------------------------------------------------------
-# Operations generating the curve as a polyline
-#-----------------------------------------------------------------------------
-def get_polyline_from_vtk(infile):
-    '''
-    @description
-    Extract all the segments constituing the curve from
-    the vtk file. The segments are them assembled to create
-    the polyline
-    '''
-
-    # parse the file
-    (name, ispoint, pts, lines, vals) = ParseFile(infile)
-	 
-    # for cell vars, put the point vals in a dictionary
-    linevals = {}
-    if not ispoint:
-        for i in range(len(lines)):
-            seg = lines[i]
-            linevals[seg[0],seg[1]] = vals[i]
-            linevals[seg[1],seg[0]] = vals[i]
-            
-    # group the line segments into polylines, first pass
-    polylines = []
-    for seg in lines:
-        found = False
-        for i in range(len(polylines)):
-            # if we can stick it on either end of a polyline, do it
-            if seg[0] == polylines[i][0]:
-                polylines[i].insert(0,seg[1])
-                found = True
-            elif seg[1] == polylines[i][0]:
-                polylines[i].insert(0,seg[0])
-                found = True
-            elif seg[0] == polylines[i][-1]:
-                polylines[i].append(seg[1])
-                found = True
-            elif seg[1] == polylines[i][-1]:
-                polylines[i].append(seg[0])
-                found = True
-            if found:
-                break
-        if found == False:
-            polylines.append(seg)
-	 
-    # now group up the polylines until we can't do it anymore
-    done = False
-    while not done:
-        done = True
-        for i in range(len(polylines)):
-            for j in range(i):
-                polyi = polylines[i]
-                polyj = polylines[j]
-                # if either end of the polylines match, merge them
-                if polyi[0] == polyj[0]:
-                    polylines.remove(polyj)
-                    polyi.reverse()
-                    polyi.extend(polyj[1:])
-                    done = False
-                elif polyi[-1] == polyj[0]:
-                    polylines.remove(polyj)
-                    polyi.extend(polyj[1:])
-                    done = False
-                elif polyi[0] == polyj[-1]:
-                    polylines.remove(polyi)
-                    polyj.extend(polyi[1:])
-                    done = False
-                elif polyi[-1] == polyj[-1]:
-                    polylines.remove(polyj)
-                    polyj.reverse()
-                    polyi.extend(polyj[1:])
-                    done = False
-	 
-                if done == False:
-                    break
-            if done == False:
-                break
-
-    return [name,ispoint,pts,polylines]
-
-
-def get_curve_coordinates(name, ispoint, pts, polylines, outfile=''):
-    '''
-    @description
-    Extract the position of the points in the polyline to
-    create the coordinate data of the curve:
-     - data[0]: x-coordinates
-     - data[1]: y-coordinates
-    These data can optionally be written on an output file
-    '''
-
-    writeOutput=(outfile!='')
-
-    if(writeOutput):
-        out = open(outfile, 'w')
-
-    data=[]
-    data.append([])
-    data.append([])
-
-    for p in range(len(polylines)):
-        polyline = polylines[p]
-
-        if(writeOutput):
-            out.write("# %s%04d\n" % (name, p))
-
-        # note it's different between cell- and point-centered values
-        if ispoint:
-            pos = 0.0
-            for i in range(len(polyline)-1):
-                pt = getpoint(pts, polyline[i])
-
-                if(writeOutput):
-                    out.write("%f %f\n" % (pt[0], pt[1]))
-
-                data[0].append(pt[0])
-                data[1].append(pt[1])
-
-        else:
-            pos = 0.0
-            lastpt = (0,0,0)
-            for i in range(len(polyline)-1):
-                pt0 = getpoint(pts, polyline[i])
-                pt1 = getpoint(pts, polyline[i+1])
-                pt = calcmid(pt0,pt1)
-
-                if(writeOutput):
-                    out.write("%f %f\n" % (pt[0], pt[1]))
-
-                data[0].append(pt[0])
-                data[1].append(pt[1])
-
-    if(writeOutput):
-        out.close()
-
-    return data
-
-
-#-----------------------------------------------------------------------------
-# Main function extracting the curve coordinates
-#-----------------------------------------------------------------------------
-def get_curve_coords_from_vtkfile(infile,outfile=''):
-
-    [name,ispoint,pts,polylines] = get_polyline_from_vtk(infile)
-
-
-    # extract the coordinate data and write output file
-    graph_data = get_curve_coordinates(name,
-                                       ispoint,
-                                       pts,
-                                       polylines,
-                                       outfile=outfile)
-
-    return graph_data
-
- 
-# ----------------------------------------------------------------------------
-#  Main routine
-# ----------------------------------------------------------------------------
-if __name__=="__main__":
-
-    # get command-line arguments
-    if len(sys.argv) != 3:
-        print "Usage:",sys.argv[0],"<inputfile.vtk> <outputfile.curve>"
-        sys.exit(1)
-        
-    infile = sys.argv[1]
-    if not os.path.exists(infile):
-        print "Error:",infile,"didn't exist."
-        sys.exit(1)
-
-
-    # extract the polyline form the vtk file
-    [name,ispoint,pts,polylines] = get_polyline_from_vtk(infile)
-
-
-    # extract the coordinate data and write output file
-    outfile = sys.argv[2]
-    graph_data = get_curve_coordinates(name,
-                                       ispoint,
-                                       polylines,
-                                       outfile=outfile)    
-
-    # plot the curve
-    width = 3
-
-    plt.rc('text', usetex=True)
-    plt.rc('font', family='serif')
-    plt.figure(figsize=(8,4))
-    ax = plt.subplot(111)
-    
-    plt.plot(
-        graph_data[0],
-        graph_data[1],
-        '-',
-        linewidth=width,
-        color='black')
-    
-    plt.show()
-    plt.close()
diff --git a/scripts_py/wall_steady_state_automatization/contours_extraction/readme.txt b/scripts_py/wall_steady_state_automatization/contours_extraction/readme.txt
deleted file mode 100644
index b662d28..0000000
--- a/scripts_py/wall_steady_state_automatization/contours_extraction/readme.txt
+++ /dev/null
@@ -1,30 +0,0 @@
-============================================================
-Author: J.L. Desmarais
-Date  : 16/06/2015
-============================================================
-python files written to create and extract the bubble
-contours from the netcdf files
-
-procedure sumary:
------------------
-
-library_nc_to_vtklines.py :
-	The data*.nc files are plotted using visit (mass contours).
-	The contours in visit are exported as vtk files which are
-	then reconstructed as continuous lines by the library
-	(library_vtklines_to_curve_positions.py). These data are
-	analyzed to find the contact length betwen the wall and the
-	bubble as well as the bubble volume.	
-
-library_vtklines_to_curve_positions.py:
-	The vtk files are analyzed to extract the polylines.
-
-library_contours_graph.py:
-	The contours extracted, the contact length and the bubble
-	volume are plotted as function of time. They are compared
-	to the spherical cap approximation.
-
-extract_contours.py:
-	This is the script which is used to run the postprocessing
-	of the bubble steady state contours.
-
diff --git a/scripts_py/wall_steady_state_automatization/run_bubble_collapse_simulations.py b/scripts_py/wall_steady_state_automatization/run_bubble_collapse_simulations.py
deleted file mode 100644
index 1472f34..0000000
--- a/scripts_py/wall_steady_state_automatization/run_bubble_collapse_simulations.py
+++ /dev/null
@@ -1,107 +0,0 @@
-#!/usr/bin/python
-
-'''
-@description
-script used to generate the main results of the
-bubble collapse closed to a wall
-
-the results are obtained by varying the ratio between
-the initial radius of the bubble and its interface width
-and the contact angle at the wall between the phases
-
-1) ratio: 1.0, 1.5, 2.0 at T=0.95 and contact angle=90.0
-
-1) contact angle: 22.5, 45.0, 67.5, 90.0 at T=0.95 and ratio=1.0
-
-'''
-
-import os
-
-from library_wall_nonst_results import generate_wall_nonst_results
-
-
-if __name__=="__main__":
-
-
-    # main directory where the simulations
-    # are saved
-    mainDir='/home/jdesmarais/projects'
-
-
-    # input used as template
-    #------------------------------------------------------------
-    maindir_input = os.path.join(os.getenv('augeanstables'),
-                                 'src','config',
-                                 'default_inputs','dim2d')
-
-    model_input = os.path.join(
-        maindir_input,
-        'dim2d_bubble_collapse.txt')
-
-    ratioStudy        = True
-    contactangleStudy = False
-
-
-    #1) ratio study
-    if(ratioStudy):
-
-        steady_state_ac = 0
-        temperature     = 0.95
-        ratio_array     = [1.5,2.0]
-        phase_at_center = 'vapor'
-        gravity_ac      = 0
-        gravity         = 0.000
-        contact_angle   = 90.0
-        total_nb_files  = 1200
-    
-        for ratio in ratio_array:
-            
-            [destDir, nameRun] =\
-                \
-                generate_wall_nonst_results(
-                mainDir,
-                model_input,
-                PBSnameRun,
-                simulationDuration,
-                steady_state_ac           = steady_state_ac,
-                temperature               = temperature,
-                micro_contact_angle       = contact_angle,
-                phase_at_center           = phase_at_center,
-                ratio_bubble_interface    = ratio,
-                gravity_ac                = gravity_ac,
-                gravity_amp               = gravity,
-                total_nb_files            = total_nb_files)
-
-
-    #2) contact_angle study
-    if(contactangleStudy):
-
-        steady_state_ac     = 0
-        temperature         = 0.95
-        ratio               = 1.0
-        contact_angle_array = [22.5,45.0,67.5,90.0,112.5,135.0]
-        phase_at_center     = 'vapor'
-        gravity_ac          = 0
-        gravity             = 0.000
-        contact_angle       = 90.0
-        total_nb_files      = 1200
-    
-        for contact_angle in contact_angle_array:
-            
-            [destDir, nameRun] =\
-                \
-                generate_wall_nonst_results(
-                mainDir,
-                model_input,
-                PBSnameRun,
-                simulationDuration,
-                steady_state_ac           = steady_state_ac,
-                temperature               = temperature,
-                micro_contact_angle       = contact_angle,
-                phase_at_center           = phase_at_center,
-                ratio_bubble_interface    = ratio,
-                gravity_ac                = gravity_ac,
-                gravity_amp               = gravity,
-                total_nb_files            = total_nb_files)
-             
-    
